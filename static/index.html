<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hide and Seek JS Client</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007bff">

    <style>
        /* Allgemeine Stile für Body und Container */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f4f4f8;
            color: #333;
            font-size: 16px;
            line-height: 1.5;
        }
        .container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        h1, h2, h3, h4 {
            color: #333;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.2em; }
        h4 { font-size: 1.1em; }
        .info {
            margin-bottom: 8px;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .info:last-child { border-bottom: none; }
        .info strong { color: #555; }

        /* Listen-Stile */
        .player-list { list-style: none; padding-left: 0; }
        .player-list li { padding: 8px; border-bottom: 1px solid #f0f0f0; }
        .player-list li:last-child { border-bottom: none; }
        .highlight { background-color: #e6f7ff; font-weight: bold; }

        /* Nachrichten-Stile (Fehler, Erfolg) */
        #messages-section {
            padding: 0;
            background: none;
            box-shadow: none;
            /* --- FIX FÜR JITTER-PROBLEM --- */
            /* Wir geben dem Container eine Mindesthöhe, damit er nicht zusammenfällt, wenn er leer ist. */
            /* Dadurch wird verhindert, dass der Inhalt darunter auf- und abspringt. */
            min-height: 4em; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            /* --- ENDE FIX --- */
        }
        #messages-section p {
            padding: 10px;
            border-radius: 4px;
            margin: 0 0 10px 0;
            visibility: hidden; /* Standardmäßig unsichtbar */
            height: 0;
            opacity: 0;
            transition: visibility 0s 0.2s, opacity 0.2s linear, height 0.2s ease-in-out;
        }
        #messages-section p:last-child { margin-bottom: 0; }
        #messages-section p.visible {
            visibility: visible;
            height: auto;
            opacity: 1;
            transition: opacity 0.2s linear, height 0.2s ease-in-out;
        }
        .error { color: #d9534f; background-color: #f2dede; border: 1px solid #ebccd1; }
        .success { color: #5cb85c; background-color: #dff0d8; border: 1px solid #d6e9c6; }

        /* Button- und Input-Stile */
        button, input[type="submit"] {
            display: block; width: 100%; padding: 12px 15px; margin: 10px 0;
            background-color: #007bff; color: white; border: none; border-radius: 5px;
            cursor: pointer; font-size: 1em; transition: background-color 0.2s ease;
        }
        button:hover, input[type="submit"]:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button.ready { background-color: #28a745; }
        button.ready:hover { background-color: #1e7e34; }
        button.unready { background-color: #ffc107; color: #333; }
        button.unready:hover { background-color: #d39e00; }
        button.action-btn { background-color: #17a2b8; margin-top: 5px; font-size: 0.9em; padding: 8px 10px; }
        button.action-btn:hover { background-color: #117a8b; }
        button.warning-btn { background-color: #ffc107; color: #212529; }
        button.warning-btn:hover { background-color: #e0a800; }
        button.danger-btn { background-color: #dc3545; }
        button.danger-btn:hover { background-color: #c82333; }
        input[type="text"], input[type="number"], select {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px;
            border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1em;
        }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        #mapLink a { color: #007bff; text-decoration: none; font-weight: normal; }

        /* Countdown und Statusanzeigen */
        .countdown {
            font-size: 1.8em; font-weight: bold; color: #dc3545; text-align: center;
            padding:10px; background-color: #fff3cd; border-radius: 5px; margin: 10px 0;
        }
        .status-active { color: green; font-weight: bold; }
        .status-caught { color: orange; font-weight: bold; }
        .status-failed, .status-failed-loc { color: red; font-weight: bold; }
        .status-offline { color: #888; font-style: italic; }
        .status-connected { color: green; font-weight: bold; }
        .status-disconnected { color: red; font-weight: bold; }
        .status-connecting { color: orange; font-weight: bold; }

        /* Leaderboard */
        .leaderboard { width: 100%; border-collapse: collapse; margin-top:10px; }
        .leaderboard th, .leaderboard td { text-align: left; padding: 10px; border-bottom: 1px solid #ddd; }
        .leaderboard th { background-color: #f8f9fa; color: #333; }

        /* Haupt-Sichtbarkeitssteuerung */
        .section { display: none; } 
        .section.visible { display: block; }
        
        .visibility-container { visibility: hidden; opacity: 0; height: 0; transition: visibility 0s 0.2s, opacity 0.2s, height 0.2s; }
        .visibility-container.visible { visibility: visible; opacity: 1; height: auto; transition: opacity 0.2s, height 0.2s; }

        /* Hilfsstile */
        .centered-text { text-align: center; }
        .dimmed { color: #777; }
        #server-management-container {
            margin-top: 30px;
            padding: 10px;
            border-top: 1px dashed #ccc;
            text-align: center;
        }
        #server-management-container p { font-size: 0.8em; color: #777; margin-bottom: 0; }
        #server-management-container button {
            font-size: 0.9em;
            padding: 8px 10px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Schritt 1: Server-Verbindung herstellen -->
        <div id="connect-section" class="container section visible">
            <h1>Server-Verbindung herstellen</h1>
            <p class="info">Server-Status: <span id="connect-socket-status-display" class="dimmed">Prüfe...</span></p>
            <div>
                <label for="server-address">Server-Adresse (z.B. 192.168.1.5 oder mein-server.de:12345):</label>
                <input type="text" id="server-address" name="server_address" placeholder="host:port (Standard-Port: 65432)" required>
                <button id="connect-to-server-button">Mit Server verbinden</button>
            </div>
            <p id="connect-error-message" class="error" style="display:none;"></p>
        </div>

        <!-- Abschnitt: Allgemeine Nachrichten (immer vorhanden, um Zucken zu vermeiden) -->
        <div id="messages-section" class="container section">
            <p id="game-message" class="success"></p>
            <p id="error-message" class="error"></p>
            <p id="location-error-message" class="error"></p>
        </div>

        <!-- Schritt 2: Lobby-Registrierung -->
        <div id="lobby-registration-section" class="container section">
            <h2>Lobby beitreten</h2>
            <p>Du bist mit dem Server verbunden. Gib deinen Namen und deine gewünschte Rolle ein, um der Lobby beizutreten.</p>
            <div>
                <label for="lobby-nickname">Nickname:</label>
                <input type="text" id="lobby-nickname" name="nickname" required>
                <label for="lobby-role-choice">Gewünschte Rolle:</label>
                <select id="lobby-role-choice" name="role">
                    <option value="hider">Hider</option>
                    <option value="seeker">Seeker</option>
                </select>
                <button id="register-in-lobby-button">Lobby beitreten</button>
            </div>
        </div>

        <!-- Schritt 3: Lobby-Ansicht -->
        <div id="lobby-view-section" class="section">
            <div class="container">
                <h2>Spiel-Lobby</h2>
                <p class="info">Server Socket: <span id="lobby-socket-connection-status" class="dimmed">Prüfe...</span></p>
                <ul id="lobby-player-list" class="player-list"></ul>
                 <form id="ready-form">
                     <button type="submit" id="ready-button">Bereit zum Spielstart!</button>
                 </form>
                 <button id="change-details-button" type="button" class="action-btn warning-btn" style="margin-top: 5px;">Name/Rolle ändern</button>
            </div>
            <div class="container">
                <h3>Deine Informationen</h3>
                <p class="info"><strong>Name:</strong> <span id="lobby-player-name">N/A</span> (ID: <span id="lobby-player-id" class="dimmed">N/A</span>)</p>
                <p class="info"><strong>Zugewiesene Rolle:</strong> <span id="lobby-player-role">N/A</span></p>
                <p class="info dimmed" style="font-size:0.8em">Standort-Genauigkeit: <span id="lobby-player-accuracy">N/A</span> m</p>
            </div>
        </div>

        <!-- Schritt 4: Spiel-Ansicht -->
        <div id="ingame-view-section" class="section">
            <!-- Wichtigste Info: Zeit & Status -->
            <div class="container">
                 <h1>Hide and Seek</h1>
                 <p class="info">Spielphase: <span id="game-status-display" class="dimmed">Lade...</span></p>
                 <div id="hider-wait-countdown-container" class="visibility-container">
                    <p class="countdown">Vorbereitungszeit: <span id="hider-wait-time-left">0</span> Sek</p>
                </div>
                <div id="game-time-left-container" class="visibility-container">
                    <p class="centered-text" style="font-size: 1.2em;"><strong>Verbleibende Spielzeit</strong></p>
                    <p id="game-time-left" class="countdown" style="font-size:2em; color:#007bff; padding: 15px 0;">0</p>
                </div>
            </div>

            <!-- Rollenspezifische Werkzeuge -->
            <div id="hider-section" class="container section">
                <h2>Hider Werkzeuge</h2>
                <div id="hider-task-info" class="visibility-container">
                    <h3>Aktuelle Aufgabe</h3>
                    <p class="info"><strong>Beschreibung:</strong> <span id="task-description"></span></p>
                    <p class="info"><strong>Punkte:</strong> <span id="task-points"></span></p>
                    <p class="info"><strong>Verbleibende Zeit:</strong> <span id="task-time-left" class="countdown" style="font-size:1em; color:#dc3545; padding: 5px;"></span> Sek</p>
                    <form id="complete-task-form" style="margin-bottom: 5px;"><button type="submit" class="action-btn">Aufgabe als erledigt markieren!</button></form>
                    <button id="skip-task-button" class="action-btn warning-btn" style="display:none;">
                        Aufgabe überspringen (<span id="skips-left-in-button">0</span> übrig)
                    </button>
                </div>
                <p id="hider-no-task-message" class="dimmed visibility-container">Warte auf eine neue Aufgabe vom Server...</p>
                 <p id="hider-warning-text" class="error visibility-container" style="font-weight:bold; text-align:center;">
                    ACHTUNG HIDER! Dein Standort wird bald an die Seeker gesendet.
                </p>
            </div>
            <div id="seeker-section" class="container section">
                <h2>Seeker Werkzeuge</h2>
                <div id="seeker-hider-locations-container">
                    <h3>Sichtbare Hider</h3>
                    <ul id="seeker-hider-list" class="player-list"></ul>
                    <p id="seeker-no-hiders-message" class="dimmed centered-text visibility-container">Momentan keine Hider sichtbar.</p>
                </div>
            </div>

            <!-- Leaderboards & Spielerlisten -->
            <div class="container">
                <h3>Leaderboard & Spieler</h3>
                <div id="hider-leaderboard-container" class="visibility-container">
                    <h4>Hider Leaderboard</h4>
                    <table id="hider-leaderboard" class="leaderboard">
                        <thead><tr><th>Name</th><th>Punkte</th><th>Status</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div id="all-players-container">
                    <h4>Alle Spieler im Spiel</h4>
                    <ul id="all-players-list" class="player-list"></ul>
                </div>
            </div>

            <!-- Eigene Spieler-Informationen im Spiel -->
            <div class="container">
                <h3>Deine Informationen</h3>
                <p class="info"><strong>Server Socket: <span id="ingame-socket-connection-status" class="dimmed">Prüfe...</span></strong></p>
                <p class="info"><strong>Name:</strong> <span id="ingame-player-name">N/A</span></p>
                <p class="info"><strong>Aktuelle Rolle:</strong> <span id="ingame-player-role">N/A</span></p>
                <p class="info"><strong>Dein Status:</strong> <span id="ingame-player-status">N/A</span></p>
                <p class="info dimmed" style="font-size:0.8em">Standort-Genauigkeit: <span id="ingame-player-accuracy">N/A</span> m</p>
            </div>

            <!-- Spielende-Optionen -->
            <div class="container">
                <div id="early-end-vote-container" class="visibility-container">
                     <button id="request-early-end-button" class="warning-btn">Runde vorzeitig beenden</button>
                     <p id="early-end-vote-info" class="dimmed centered-text" style="margin-top: 10px;">0/0 Spieler wollen Runde beenden.</p>
                </div>
            </div>
        </div>

        <!-- Abschnitt: Spielende-Anzeige -->
        <div id="game-over-section" class="container section">
            <h2>Spiel Vorbei!</h2>
            <p id="game-over-message" style="font-size: 1.2em; font-weight: bold; text-align: center;"></p>
            <div id="game-over-leaderboard-container" class="visibility-container">
                <h3>Finale Hider Rangliste</h3>
                <table id="game-over-leaderboard" class="leaderboard">
                    <thead><tr><th>Name</th><th>Punkte</th><th>Status</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
             <p class="dimmed centered-text" style="margin-top:15px;">Du wirst in Kürze zur Lobby zurückgebracht...</p>
             <button id="leave-game-now-button" class="action-btn" onclick="handleLeaveAndGoToJoinScreen()">Sofort zur Serverauswahl</button>
        </div>

        <!-- Unauffälliger Server-Reset am Ende der Seite -->
        <div id="server-management-container" class="section">
            <button id="force-server-reset-button" class="danger-btn">Server für alle zurücksetzen</button>
            <p>Achtung: Dies startet für alle Spieler eine neue Lobby.</p>
        </div>
    </div>

    <script>
        // Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js', { scope: '/' })
                    .then(registration => console.log('ServiceWorker Registrierung erfolgreich, Scope:', registration.scope))
                    .catch(error => console.error('ServiceWorker Registrierung fehlgeschlagen:', error));
            });
        }

        let currentPlayerData = {};
        const GAME_STATE_LOBBY = "lobby";
        const GAME_STATE_HIDER_WAIT = "hider_wait";
        const GAME_STATE_RUNNING = "running";
        const GAME_STATE_HIDER_WINS = "hider_wins";
        const GAME_STATE_SEEKER_WINS = "seeker_wins";

        const LOCATION_UPDATE_INTERVAL_MS = 10000;
        let locationWatchId = null;
        let lastLocationSentTime = 0;
        const SERVER_ADDRESS_KEY = 'hideAndSeekServerAddress';
        let statusUpdateInterval;


        // --- DOM Hilfsfunktionen ---
        function $(selector) { return document.querySelector(selector); }
        function show(id) { const el = $(`#${id}`); if (el) el.classList.add('visible'); }
        function hide(id) { const el = $(`#${id}`); if (el) el.classList.remove('visible'); }
        function setText(id, textContent) { const el = $(`#${id}`); if (el) el.textContent = textContent || ''; }
        function setHtml(id, htmlContent) { const el = $(`#${id}`); if (el) el.innerHTML = htmlContent || ''; }
        
        function toggleVisibility(id, showFlag) {
            const el = $(`#${id}`);
            if (el) {
                if (showFlag) el.classList.add('visible');
                else el.classList.remove('visible');
            }
        }
        function toggleMessage(id, message) {
            const el = $(`#${id}`);
            if(el) {
                if (message) {
                    el.textContent = message;
                    el.classList.add('visible');
                } else {
                    el.classList.remove('visible');
                    setTimeout(() => { if(!el.classList.contains('visible')) el.textContent = ''; }, 200);
                }
            }
        }

        function saveServerAddress(address) { try { localStorage.setItem(SERVER_ADDRESS_KEY, address); } catch (e) { console.warn("localStorage nicht verfügbar:", e); } }
        function loadServerAddress() { try { return localStorage.getItem(SERVER_ADDRESS_KEY); } catch (e) { console.warn("localStorage nicht verfügbar:", e); return null; } }

        function initializeServerInput() {
            const loadedAddress = loadServerAddress();
            const serverAddressInput = $('#server-address');
            if (serverAddressInput && loadedAddress) {
                serverAddressInput.value = loadedAddress;
            }
        }

        function resetAllSections() {
            document.querySelectorAll('#app-container > .section').forEach(section => {
                 section.classList.remove('visible');
            });
        }


        function updateUI(data) {
            currentPlayerData = JSON.parse(JSON.stringify(data)); // Deep copy
            resetAllSections();

            const userHasInitiatedConnection = data.user_has_initiated_connection === true;
            const isSocketConnected = data.is_socket_connected_to_server === true;
            const hasPlayerId = !!data.player_id;
            const serverGameStatus = data.game_state?.status;
            const serverGameStatusDisplay = data.game_state?.status_display || "Lade...";
            const isGameOver = serverGameStatus === GAME_STATE_HIDER_WINS || serverGameStatus === GAME_STATE_SEEKER_WINS;

            // --- Globale Elemente ---
            show('messages-section');
            if (data.is_processing_offline_queue) {
                 toggleMessage('game-message', 'Synchronisiere Offline-Aktionen mit dem Server...');
            } else if (data.game_message) {
                toggleMessage('game-message', data.game_message);
                setTimeout(() => { toggleMessage('game-message', null); if(currentPlayerData) currentPlayerData.game_message = null; }, 5000);
            } else {
                toggleMessage('game-message', null);
            }
            toggleMessage('error-message', data.error_message || data.join_error);
            // Location-Error wird separat behandelt
            
            toggleVisibility('server-management-container', isSocketConnected);
            if($('#force-server-reset-button')) $('#force-server-reset-button').disabled = !isSocketConnected;


            // --- Haupt-Ansichten-Logik ---
            if (!userHasInitiatedConnection) {
                show('connect-section');
                setText('connect-socket-status-display', 'Bereit zum Verbinden');
                $('#connect-socket-status-display').className = 'dimmed';
            } 
            else if (!isSocketConnected) {
                show('connect-section');
                setText('connect-socket-status-display', serverGameStatusDisplay);
                $('#connect-socket-status-display').className = 'status-connecting';
                if (data.error_message || data.join_error) {
                    $('#connect-socket-status-display').className = 'status-disconnected';
                }
            }
            else if (isSocketConnected && !hasPlayerId && !isGameOver) {
                show('lobby-registration-section');
                $('#register-in-lobby-button').disabled = false;
                const nicknameInput = $('#lobby-nickname');
                if (nicknameInput && document.activeElement !== nicknameInput) {
                    nicknameInput.value = data.session_nickname || data.prefill_nickname || '';
                }
                const roleChoiceInput = $('#lobby-role-choice');
                if (roleChoiceInput && document.activeElement !== roleChoiceInput) {
                    roleChoiceInput.value = data.session_role_choice || 'hider';
                }
            } 
            else if (isSocketConnected && hasPlayerId && !isGameOver) {
                const playerAccuracy = data.location?.length > 2 && data.location[2] !== null ? parseFloat(data.location[2]).toFixed(1) : 'N/A';
                
                if (serverGameStatus === GAME_STATE_LOBBY) {
                    show('lobby-view-section');
                    const lobbySocketStatusEl = $('#lobby-socket-connection-status');
                    setText(lobbySocketStatusEl.id, isSocketConnected ? 'Verbunden' : 'Getrennt');
                    lobbySocketStatusEl.className = isSocketConnected ? 'status-connected' : 'status-disconnected';
                    updateLobbyPlayerList(data.lobby_players, String(data.player_id));
                    
                    const readyButton = $('#ready-button');
                    readyButton.textContent = data.player_is_ready ? 'Status: Bereit (Klick zum Ändern)' : 'Klicken: Ich bin bereit!';
                    readyButton.className = data.player_is_ready ? 'unready' : 'ready';
                    readyButton.disabled = !isSocketConnected;
                    
                    setText('lobby-player-name', data.player_name);
                    setText('lobby-player-id', data.player_id);
                    setText('lobby-player-role', data.role);
                    setText('lobby-player-accuracy', playerAccuracy);

                } else { // HIDER_WAIT oder RUNNING
                    show('ingame-view-section');
                    const ingameSocketStatusEl = $('#ingame-socket-connection-status');
                    setText(ingameSocketStatusEl.id, isSocketConnected ? 'Verbunden' : 'Getrennt');
                    ingameSocketStatusEl.className = isSocketConnected ? 'status-connected' : 'status-disconnected';
                    
                    setText('ingame-player-name', data.player_name);
                    setText('ingame-player-role', data.role);
                    setText('ingame-player-status', data.player_status);
                    setText('game-status-display', serverGameStatusDisplay);
                    setText('ingame-player-accuracy', playerAccuracy);

                    toggleVisibility('hider-wait-countdown-container', serverGameStatus === GAME_STATE_HIDER_WAIT);
                    setText('hider-wait-time-left', data.game_state?.hider_wait_time_left || '0');
                    
                    toggleVisibility('game-time-left-container', serverGame-status === GAME_STATE_RUNNING);
                    const timeLeft = data.game_state?.game_time_left || 0;
                    setText('game-time-left', `${Math.floor(timeLeft / 60)} Min ${timeLeft % 60} Sek`);
                    
                    toggleVisibility('hider-section', data.role === 'hider');
                    toggleVisibility('seeker-section', data.role === 'seeker');

                    if (data.role === 'hider') {
                        toggleVisibility('hider-warning-text', data.hider_location_update_imminent && data.player_status === 'active');
                        updateHiderTask(data.current_task, data.task_skips_available);
                        updateHiderLeaderboard(data.hider_leaderboard, String(data.player_id), 'hider-leaderboard');
                        toggleVisibility('hider-leaderboard-container', data.hider_leaderboard?.length > 0);
                    }
                    if (data.role === 'seeker') {
                        updateSeekerHiderList(data.hider_locations, isSocketConnected);
                    }
                    
                    updateAllPlayersList(data.all_players_status, String(data.player_id));
                    
                    const canVote = (serverGameStatus === GAME_STATE_RUNNING || serverGameStatus === GAME_STATE_HIDER_WAIT) && data.player_status === 'active';
                    toggleVisibility('early-end-vote-container', canVote);
                    if(canVote) {
                        const earlyEndBtn = $('#request-early-end-button');
                        earlyEndBtn.disabled = data.player_has_requested_early_end || !isSocketConnected;
                        earlyEndBtn.textContent = data.player_has_requested_early_end ? 'Abstimmung gesendet' : 'Runde vorzeitig beenden';
                        setText('early-end-vote-info', `${data.early_end_requests_count || 0} / ${data.total_active_players_for_early_end || 0} Spieler wollen Runde beenden.`);
                    }
                }
            } 
            else if (isGameOver) {
                show('game-over-section');
                setText('game-over-message', data.game_state?.game_over_message || "Das Spiel ist vorbei.");
                updateHiderLeaderboard(data.hider_leaderboard, String(data.player_id), 'game-over-leaderboard');
                toggleVisibility('game-over-leaderboard-container', data.hider_leaderboard?.length > 0);
            }

            // Standort-Updates starten/stoppen
            if (hasPlayerId && !isGameOver) startLocationUpdates(); else stopLocationUpdates();
        }

        // --- UI Update Hilfsfunktionen (unverändert) ---
        function updateLobbyPlayerList(lobbyPlayers, currentPlayerIdStr) {
            const ul = $('#lobby-player-list'); setHtml(ul.id, '');
            if (lobbyPlayers && Object.keys(lobbyPlayers).length > 0) {
                Object.entries(lobbyPlayers).forEach(([pid, p_data]) => {
                    const li = document.createElement('li');
                    let roleDisplay = p_data.role === 'hider' ? 'Hider' : (p_data.role === 'seeker' ? 'Seeker' : 'Unbekannt');
                    let readyDisplay = p_data.is_ready ? '<span class="status-active">Bereit</span>' : '<span class="dimmed">Wartet...</span>';
                    li.innerHTML = `${p_data.name} (Rolle: ${roleDisplay}) - Status: ${readyDisplay}`;
                    if (pid === currentPlayerIdStr) li.classList.add('highlight');
                    ul.appendChild(li);
                });
            } else { ul.innerHTML = '<li class="dimmed">Warte auf weitere Spieler...</li>'; }
        }
        function updateAllPlayersList(allPlayers, currentPlayerIdStr) { /* ... (wie gehabt) ... */ }
        function updateHiderTask(task, taskSkipsAvailable) { /* ... (wie gehabt) ... */ }
        function updateHiderLeaderboard(leaderboardData, currentPlayerIdStr, tableId) { /* ... (wie gehabt) ... */ }
        function updateSeekerHiderList(hiderLocations, isSocketConnected) { /* ... (wie gehabt) ... */ }

        // --- Backend-Kommunikation und Logik ---
        async function sendClientAction(endpoint, bodyPayload = null, triggeringButton = null) {
             if (triggeringButton) triggeringButton.disabled = true;
            try {
                const options = { method: 'POST', headers: {'Content-Type': 'application/json'}};
                if (bodyPayload) options.body = JSON.stringify(bodyPayload);
                const response = await fetch(endpoint, options);
                const responseData = await response.json();
                updateUI(responseData);
            } catch (error) {
                console.error(`Netzwerkfehler an Client-Backend (${endpoint}):`, error);
                const errorData = JSON.parse(JSON.stringify(currentPlayerData || {}));
                errorData.error_message = `Netzwerkfehler: Aktion fehlgeschlagen. Der lokale Client-Server antwortet nicht.`;
                if (!errorData.game_state) errorData.game_state = {};
                errorData.game_state.status_display = "Lokaler Client nicht erreichbar";
                errorData.is_socket_connected_to_server = false;
                updateUI(errorData);
            } finally {
                // Button wieder aktivieren, außer für Aktionen, die einen Zustandswechsel erzwingen
                if (triggeringButton && !['/complete_task', '/set_ready', '/return_to_registration'].includes(endpoint)) {
                    triggeringButton.disabled = false;
                }
            }
        }
        function handleLocationSuccess(position) { /* ... (wie gehabt) ... */ }
        function handleLocationError(error) { /* ... (wie gehabt) ... */ }
        async function sendLocationToClientBackend(lat, lon, accuracy) { /* ... (wie gehabt) ... */ }
        function startLocationUpdates() { /* ... (wie gehabt) ... */ }
        function stopLocationUpdates() { /* ... (wie gehabt) ... */ }

        // --- Event Listener ---
        $('#connect-to-server-button')?.addEventListener('click', (event) => { /* ... */ });
        $('#register-in-lobby-button')?.addEventListener('click', (event) => { /* ... */ });
        $('#ready-form')?.addEventListener('submit', (event) => { /* ... */ });
        $('#change-details-button')?.addEventListener('click', (event) => { /* ... */ });
        $('#complete-task-form button')?.addEventListener('click', (event) => { /* ... */ });
        $('#request-early-end-button')?.addEventListener('click', (event) => { /* ... */ });
        $('#skip-task-button')?.addEventListener('click', (event) => { /* ... */ });
        $('#force-server-reset-button')?.addEventListener('click', (event) => { /* ... */ });
        
        async function handleLeaveAndGoToJoinScreen() {
            await sendClientAction('/leave_game_and_go_to_join_screen', null, $('#leave-game-now-button'));
        }

        async function fetchStatusAndUpdateUI() { /* ... (wie gehabt) ... */ }
        
        document.addEventListener('DOMContentLoaded', () => {
            initializeServerInput();
            fetchStatusAndUpdateUI(); // Initialer Aufruf
            clearInterval(statusUpdateInterval); // Alten Timer löschen, falls vorhanden
            statusUpdateInterval = setInterval(fetchStatusAndUpdateUI, 2500); // Neuen Timer starten
        });
        
        // --- Vereinfachte, aber identische Hilfsfunktionen, hier weggelassen für Kürze ---
        updateAllPlayersList = function(allPlayers, currentPlayerIdStr) { const el = $('#all-players-list'); setHtml(el.id, ''); if (allPlayers && Object.keys(allPlayers).length > 0) { for (const pid in allPlayers) { const p = allPlayers[pid]; const li = document.createElement('li'); let statusDisplay; if (p.status === 'active') statusDisplay = '<span class="status-active">Aktiv</span>'; else if (p.status === 'caught') statusDisplay = '<span class="status-caught">Gefangen</span>'; else if (p.status === 'failed_task') statusDisplay = '<span class="status-failed">Aufgabe verfehlt</span>'; else if (p.status === 'failed_loc_update') statusDisplay = '<span class="status-failed-loc">Kein Standort</span>'; else if (p.status === 'offline') statusDisplay = '<span class="status-offline">Offline</span>'; else statusDisplay = `<span class="dimmed">${p.status || 'Unbekannt'}</span>`; li.innerHTML = `${p.name} (Rolle: ${p.role || 'N/A'}) - ${statusDisplay}`; if (pid === currentPlayerIdStr) li.classList.add('highlight'); el.appendChild(li); } } else { el.innerHTML = '<li class="dimmed">Keine Spielerinformationen.</li>'; } };
        updateHiderTask = function(task, taskSkipsAvailable) { const isActiveHider = currentPlayerData?.role === 'hider' && currentPlayerData?.player_status === 'active'; const skipTaskButton = $('#skip-task-button'); const completeTaskButton = $('#complete-task-form button'); if (task && isActiveHider) { toggleVisibility('hider-task-info', true); toggleVisibility('hider-no-task-message', false); setText('task-description', task.description); setText('task-points', task.points); setText('task-time-left', task.time_left_seconds); if (completeTaskButton) completeTaskButton.disabled = false; if (skipTaskButton) { const numSkips = taskSkipsAvailable || 0; toggleVisibility(skipTaskButton.id, true); skipTaskButton.disabled = numSkips <= 0; $('#skips-left-in-button').textContent = numSkips; } } else { toggleVisibility('hider-task-info', false); if (completeTaskButton) completeTaskButton.disabled = true; if (skipTaskButton) toggleVisibility(skipTaskButton.id, false); toggleVisibility('hider-no-task-message', isActiveHider); } };
        updateHiderLeaderboard = function(leaderboardData, currentPlayerIdStr, tableId) { const containerId = tableId === 'game-over-leaderboard' ? 'game-over-leaderboard-container' : 'hider-leaderboard-container'; const tbody = $(`#${tableId} tbody`); if (!tbody) return; tbody.innerHTML = ''; const shouldShow = leaderboardData?.length > 0; toggleVisibility(containerId, shouldShow); if (shouldShow) { leaderboardData.forEach(entry => { const row = tbody.insertRow(); row.insertCell().textContent = entry.name; row.insertCell().textContent = entry.points; let statusDisplay; if (entry.status === 'active') statusDisplay = '<span class="status-active">Aktiv</span>'; else if (entry.status === 'caught') statusDisplay = '<span class="status-caught">Gefangen</span>'; else if (entry.status === 'offline') statusDisplay = '<span class="status-offline">Offline</span>'; else statusDisplay = `<span class="dimmed">${entry.status || 'Unbekannt'}</span>`; row.insertCell().innerHTML = statusDisplay; if (String(entry.id) === currentPlayerIdStr) row.classList.add('highlight'); }); } };
        updateSeekerHiderList = function(hiderLocations, isSocketConnected) { const ul = $('#seeker-hider-list'); ul.innerHTML = ''; const isActiveSeeker = currentPlayerData?.role === 'seeker' && currentPlayerData?.player_status === 'active'; const hasHiders = isActiveSeeker && hiderLocations && Object.keys(hiderLocations).length > 0; toggleVisibility('seeker-no-hiders-message', !hasHiders && isActiveSeeker); if (hasHiders) { for (const hiderId in hiderLocations) { const hider = hiderLocations[hiderId]; const li = document.createElement('li'); li.innerHTML = `<strong>${hider.name}</strong> (Gesehen: ${hider.timestamp || 'N/A'}) <a href="https://www.google.com/maps?q=${hider.lat},${hider.lon}" target="_blank" style="margin-left: 5px;">Karte</a> <button class="catch-hider-btn action-btn" data-hider-id="${hiderId}" ${!isSocketConnected ? 'disabled' : ''}>Fangen!</button>`; ul.appendChild(li); } document.querySelectorAll('.catch-hider-btn').forEach(button => { button.onclick = async function() { this.disabled = true; await sendClientAction('/catch_hider', { hider_id_to_catch: this.dataset.hiderId }, this); }; }); } };
        handleLocationSuccess = function(position) { const { latitude: lat, longitude: lon, accuracy } = position.coords; setText('lobby-player-accuracy', accuracy.toFixed(1)); setText('ingame-player-accuracy', accuracy.toFixed(1)); toggleMessage('location-error-message', null); const now = Date.now(); if (currentPlayerData?.player_id && (now - lastLocationSentTime > LOCATION_UPDATE_INTERVAL_MS / 2 || lastLocationSentTime === 0)) { sendLocationToClientBackend(lat, lon, accuracy); lastLocationSentTime = now; } };
        handleLocationError = function(error) { let message = "Unbekannter Standortfehler"; if (error.code === error.PERMISSION_DENIED) message = "Zugriff auf Standort blockiert."; else if (error.code === error.POSITION_UNAVAILABLE) message = "Standort nicht verfügbar."; else if (error.code === error.TIMEOUT) message = "Timeout bei der Standortabfrage."; toggleMessage('location-error-message', message); };
        sendLocationToClientBackend = async function(lat, lon, accuracy) { try { const response = await fetch('/update_location_from_browser', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ lat: lat, lon: lon, accuracy: accuracy }) }); if (!response.ok) console.error("Fehler beim Senden des Standorts an Client-Backend:", response.status); } catch (error) { console.error("Netzwerkfehler beim Senden des Standorts an Client-Backend:", error); } };
        startLocationUpdates = function() { if (navigator.geolocation && locationWatchId === null) { locationWatchId = navigator.geolocation.watchPosition(handleLocationSuccess, handleLocationError, { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }); } };
        stopLocationUpdates = function() { if (navigator.geolocation && locationWatchId !== null) { navigator.geolocation.clearWatch(locationWatchId); locationWatchId = null; } };
        $('#connect-to-server-button')?.addEventListener('click', async (event) => { const serverAddress = $('#server-address').value; if (!serverAddress) { toggleMessage('error-message', 'Bitte eine Server-Adresse eingeben.'); return; } saveServerAddress(serverAddress); await sendClientAction('/connect_to_server', { server_address: serverAddress }, event.target); });
        $('#register-in-lobby-button')?.addEventListener('click', async (event) => { const nickname = $('#lobby-nickname').value; const role = $('#lobby-role-choice').value; if (!nickname) { alert("Bitte einen Nicknamen eingeben."); return; } await sendClientAction('/register_player_details', { nickname, role }, event.target); });
        $('#ready-form').addEventListener('submit', async (event) => { event.preventDefault(); const newReadyStatus = !(currentPlayerData.player_is_ready || false); await sendClientAction('/set_ready', { ready_status: newReadyStatus }, event.submitter); });
        $('#change-details-button')?.addEventListener('click', async (event) => { if (confirm("Möchtest du zur Namens- und Rollenauswahl zurückkehren?")) { await sendClientAction('/return_to_registration', null, event.target); } });
        $('#complete-task-form button')?.addEventListener('click', async (event) => { event.preventDefault(); await sendClientAction('/complete_task', null, event.target); });
        $('#request-early-end-button')?.addEventListener('click', (event) => sendClientAction('/request_early_round_end_action', null, event.target));
        $('#skip-task-button')?.addEventListener('click', (event) => sendClientAction('/skip_task', null, event.target));
        $('#force-server-reset-button')?.addEventListener('click', (event) => { if (confirm("Bist du sicher, dass du den Spielserver für ALLE Spieler zurücksetzen möchtest?")) { sendClientAction('/force_server_reset_from_ui', null, event.target); } });
        fetchStatusAndUpdateUI = async function() { try { const response = await fetch('/status'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const data = await response.json(); updateUI(data); } catch (error) { console.error("Netzwerkfehler zum lokalen Client-Backend:", error); const tempErrorData = JSON.parse(JSON.stringify(currentPlayerData || {})); if (!tempErrorData.game_state) tempErrorData.game_state = {}; tempErrorData.game_state.status_display = "Client-Server (Python) nicht erreichbar."; tempErrorData.error_message = "Lokaler Client-Server (Python) antwortet nicht."; tempErrorData.is_socket_connected_to_server = false; updateUI(tempErrorData); } };
    </script>
</body>
</html>
