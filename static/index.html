<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hide and Seek JS Client</title>
    <!-- PWA Manifest und Theme-Farbe für App-Erfahrung -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007bff">

    <style>
        /* Allgemeine Stile für Body und Container */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f4f4f8;
            color: #333;
            font-size: 16px;
            line-height: 1.5;
        }
        .container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        h1, h2, h3 {
            color: #333;
            margin-top: 0;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.2em; }
        .info {
            margin-bottom: 8px;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .info:last-child { border-bottom: none; }
        .info strong { color: #555; }

        /* Listen-Stile */
        .player-list {
            list-style: none;
            padding-left: 0;
        }
        .player-list li {
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        .player-list li:last-child { border-bottom: none; }
        .highlight {
            background-color: #e6f7ff;
            font-weight: bold;
        }

        /* Nachrichten-Stile (Fehler, Erfolg) */
        .error {
            color: #d9534f;
            background-color: #f2dede;
            border: 1px solid #ebccd1;
            padding: 10px;
            border-radius: 4px;
            margin-top:10px;
        }
        .success {
            color: #5cb85c;
            background-color: #dff0d8;
            border: 1px solid #d6e9c6;
            padding: 10px;
            border-radius: 4px;
            margin-top:10px;
        }
        #messages-section p { margin: 5px 0;}

        /* Button- und Input-Stile */
        button, input[type="submit"] {
            display: block;
            width: 100%;
            padding: 12px 15px;
            margin: 10px 0;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        button:hover, input[type="submit"]::hover { background-color: #0056b3; }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        button.ready { background-color: #28a745; }
        button.ready:hover { background-color: #1e7e34; }
        button.unready { background-color: #ffc107; color: #333; }
        button.unready:hover { background-color: #d39e00; }
        button.action-btn {
            background-color: #17a2b8;
            margin-top: 5px;
            font-size: 0.9em;
            padding: 8px 10px;
        }
        button.action-btn:hover { background-color: #117a8b; }
        button.warning-btn {
            background-color: #ffc107;
            color: #212529;
        }
        button.warning-btn:hover { background-color: #e0a800; }
        button.danger-btn {
            background-color: #dc3545;
        }
        button.danger-btn:hover {
            background-color: #c82333;
        }
        input[type="text"], input[type="number"], select {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        #mapLink a {
            color: #007bff;
            text-decoration: none;
            font-weight: normal;
        }

        /* Countdown und Statusanzeigen */
        .countdown {
            font-size: 1.8em;
            font-weight: bold;
            color: #dc3545;
            text-align: center;
            padding:10px;
            background-color: #fff3cd;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status-active { color: green; font-weight: bold; }
        .status-caught { color: orange; font-weight: bold; }
        .status-failed, .status-failed-loc { color: red; font-weight: bold; }
        .status-offline { color: #888; font-style: italic; } /* NEU: Für Offline-Status */
        /* Neu für Verbindungsstatus */
        .status-connected { color: green; font-weight: bold; }
        .status-disconnected { color: red; font-weight: bold; }
        .status-connecting { color: orange; font-weight: bold; }


        /* Leaderboard */
        .leaderboard {
            width: 100%;
            border-collapse: collapse;
            margin-top:10px;
        }
        .leaderboard th, .leaderboard td {
            text-align: left;
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        .leaderboard th {
            background-color: #f8f9fa;
            color: #333;
        }

        /* Sektionen-Anzeige */
        .section { display: none; }
        .visible { display: block !important; }

        /* Hilfsstile */
        .centered-text { text-align: center; }
        .dimmed { color: #777; }
        #early-end-vote-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
        }
        #server-management-container {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px dashed #ccc;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Abschnitt: Spiel beitreten -->
        <div id="join-section" class="container section">
            <h1>Spiel beitreten</h1>
            <!-- Anzeige des Socket-Verbindungsstatus für den Beitritts-Screen -->
            <p class="info">Server Socket: <span id="join-socket-status-display" class="dimmed">Prüfe...</span></p>
            <p class="info">Spiel Status: <span id="join-game-status-display" class="dimmed">Verbinde...</span></p>
            <form id="join-form">
                <label for="server-host">Server IP/Hostname:</label>
                <input type="text" id="server-host" name="server_host" value="127.0.0.1" required>
                <label for="server-port">Server Port:</label>
                <input type="number" id="server-port" name="server_port" value="65432" min="1" max="65535" required>

                <label for="nickname">Nickname:</label>
                <input type="text" id="nickname" name="nickname" required>
                <label for="role-choice">Gewünschte Rolle:</label>
                <select id="role-choice" name="role">
                    <option value="hider">Hider</option>
                    <option value="seeker">Seeker</option>
                </select>
                <button type="submit" id="join-game-button">Spiel suchen & Registrieren</button>
            </form>
            <p id="join-error-message" class="error" style="display:none;"></p>
        </div>

        <!-- Abschnitt: Ausstehender Lobby-Beitritt (nach erfolgreicher Registrierung am Server) -->
        <div id="pending-lobby-join-section" class="container section">
            <h2>Registrierung zum Server erfolgreich!</h2>
            <p>Du bist beim Spielserver als <strong id="pending-lobby-player-name"></strong> (<span id="pending-lobby-player-role-wish"></span>) angemeldet.</p>
            <p>Server Socket: <span id="pending-lobby-socket-status-display" class="dimmed">Warte auf Server...</span></p>
            <p>Spiel Status: <span id="pending-lobby-game-status-display" class="dimmed">Warte auf Server...</span></p>
            <p>Klicke unten, um der aktiven Spiel-Lobby beizutreten und dich für den Spielstart bereitzumachen.</p>
            <button id="confirm-lobby-join-button">Der Lobby beitreten</button>
        </div>

        <!-- Abschnitt: Haupt-Spielerinformationen (immer sichtbar, wenn im Spiel) -->
        <div id="player-section" class="container section">
            <h1>Hide and Seek</h1>
            <!-- Neu: Anzeige des Socket-Verbindungsstatus im Spiel -->
            <p class="info"><strong>Server Socket: <span id="player-socket-connection-status" class="dimmed">Prüfe...</span></strong></p>
            <p class="info"><strong>Name:</strong> <span id="player-name">N/A</span> (ID: <span id="player-id" class="dimmed">N/A</span>)</p>
            <p class="info"><strong>Aktuelle Rolle:</strong> <span id="player-role">N/A</span></p>
            <p class="info"><strong>Dein Status:</strong> <span id="player-status-ingame">N/A</span></p>
            <p class="info"><strong>Spielphase:</strong> <span id="game-status-display" class="dimmed">Lade...</span></p>
            <div id="hider-wait-countdown-container" style="display:none;">
                <p class="countdown">Hider Vorbereitungszeit: <span id="hider-wait-time-left">0</span> Sek</p>
            </div>
            <div id="game-time-left-container" style="display:none;">
                <p class="info centered-text"><strong>Verbleibende Spielzeit:</strong> <span id="game-time-left" class="countdown" style="font-size:1.2em; color:#007bff;">0</span></p>
            </div>
            <p class="info"><strong>Deine Position:</strong> <span id="player-location" class="dimmed">Warte auf GPS...</span>
                <span id="mapLink" style="display:none;"><a href="#" target="_blank">(Auf Karte zeigen)</a></span>
            </p>
            <p class="info dimmed" style="font-size:0.8em">Standort-Genauigkeit: <span id="player-accuracy">N/A</span> m</p>
            <p id="hider-warning-text" class="error" style="display:none; font-weight:bold; text-align:center;">
                ACHTUNG HIDER! Dein Standort wird bald an die Seeker gesendet. Stelle sicher, dass die App deinen aktuellen Standort übermittelt!
            </p>
            <div id="early-end-vote-container" style="display:none;">
                 <button id="request-early-end-button" class="warning-btn">Runde vorzeitig beenden</button>
                 <p id="early-end-vote-info" class="dimmed">0/0 Spieler wollen Runde beenden.</p>
            </div>
            <div id="server-management-container" style="display:none;">
                <h3>Server Management</h3>
                <button id="force-server-reset-button" class="danger-btn">Server zurücksetzen (für alle Spieler)</button>
                <p class="dimmed" style="font-size: 0.8em;">Achtung: Dies setzt den Server für alle aktuellen Spieler zurück und startet eine neue Lobby.</p>
            </div>
        </div>

        <!-- Abschnitt: Allgemeine Nachrichten (Fehler, Erfolge, Standortfehler) -->
        <div id="messages-section" class="container section" style="padding:0;">
            <p id="game-message" class="success" style="display:none;"></p>
            <p id="error-message" class="error" style="display:none;"></p>
            <p id="location-error-message" class="error" style="display:none;"></p>
        </div>

        <!-- Abschnitt: Lobby-Ansicht -->
        <div id="lobby-section" class="container section">
            <h2>Aktive Spiel-Lobby</h2>
            <p>Spiel startet, sobald alle beigetretenen Spieler bereit sind.</p>
            <ul id="lobby-player-list" class="player-list"></ul>
            <form id="ready-form">
                <button type="submit" id="ready-button">Bereit zum Spielstart!</button>
            </form>
        </div>

        <!-- Abschnitt: Hider-spezifische Informationen -->
        <div id="hider-section" class="container section">
            <h2>Hider Informationen</h2>
            <p class="info"><strong>Verfügbare Aufgaben-Skips:</strong> <span id="hider-skips-available-display">0</span></p>
            <div id="hider-task-info" class="task-info" style="display:none;">
                <h3>Aktuelle Aufgabe</h3>
                <p><strong>Beschreibung:</strong> <span id="task-description"></span></p>
                <p><strong>Punkte:</strong> <span id="task-points"></span></p>
                <p><strong>Verbleibende Zeit:</strong> <span id="task-time-left" class="countdown" style="font-size:1em; color:#dc3545;"></span> Sek</p>
                <form id="complete-task-form" style="margin-bottom: 5px;"><button type="submit" class="action-btn">Aufgabe als erledigt markieren!</button></form>
                <button id="skip-task-button" class="action-btn warning-btn" style="display:none;">
                    Aufgabe überspringen (<span id="skips-left-in-button">0</span> übrig)
                </button>
            </div>
            <p id="hider-no-task-message" style="display:none;" class="dimmed">Warte auf eine neue Aufgabe vom Server...</p>
            <p id="hider-caught-message" class="error" style="display:none;">Du wurdest gefangen! Du bist jetzt ein Seeker.</p>
            <p id="hider-failed-task-message" class="error" style="display:none;">Du hast deine letzte Aufgabe nicht rechtzeitig geschafft und bist ausgeschieden.</p>
            <p id="hider-failed-location-message" class="error" style="display:none;">Standort nicht rechtzeitig aktualisiert - disqualifiziert!</p>

            <!-- NEU: Abschnitt für pre-cached Aufgaben -->
            <div id="hider-precached-tasks-container" style="display:none; margin-top:15px; padding-top:10px; border-top: 1px dashed #eee;">
                <h4>Nächste verfügbare Aufgaben (Offline-Cache)</h4>
                <ul id="hider-precached-tasks-list" class="player-list"></ul>
                <p class="dimmed" style="font-size:0.85em;">Diese Aufgaben werden dir bei Bedarf zugewiesen. Zeitlimits gelten ab Server-Zuweisung.</p>
            </div>


            <div id="hider-leaderboard-container" style="display:none;">
                <h3>Hider Leaderboard</h3>
                <table id="hider-leaderboard" class="leaderboard">
                    <thead><tr><th>Name</th><th>Punkte</th><th>Status</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Abschnitt: Seeker-spezifische Informationen -->
        <div id="seeker-section" class="container section">
            <h2>Seeker Informationen</h2>
            <div id="seeker-hider-locations-container">
                <h3>Sichtbare Hider</h3>
                <ul id="seeker-hider-list" class="player-list"></ul>
                <p id="seeker-no-hiders-message" style="display:none;" class="dimmed centered-text">Momentan keine Hider sichtbar oder alle Hider wurden bereits gefangen.</p>
            </div>
        </div>

        <!-- Abschnitt: Alle Spieler im Spiel -->
        <div id="all-players-section" class="container section">
            <h3>Alle Spieler im Spiel</h3>
            <ul id="all-players-list" class="player-list"></ul>
        </div>

        <!-- Abschnitt: Spielende-Anzeige -->
        <div id="game-over-section" class="container section">
            <h2>Spiel Vorbei!</h2>
            <p id="game-over-message" style="font-size: 1.2em; font-weight: bold; text-align: center;"></p>
            <div id="game-over-leaderboard-container" style="display:none;">
                <h3>Finale Hider Rangliste</h3>
                <table id="game-over-leaderboard" class="leaderboard">
                    <thead><tr><th>Name</th><th>Punkte</th><th>Status</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <button id="go-to-registration-button" onclick="handleGoToRegistration()">Neues Spiel registrieren</button>
        </div>
    </div>

    <script>
        // Service Worker Registrierung für PWA Funktionalität
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js', { scope: '/' })
                    .then(registration => console.log('ServiceWorker Registrierung erfolgreich, Scope:', registration.scope))
                    .catch(error => console.error('ServiceWorker Registrierung fehlgeschlagen:', error));
            });
        }

        let currentPlayerData = {}; // Enthält die zuletzt vom Client-Backend erhaltenen Spieldaten

        const GAME_STATE_LOBBY = "lobby";
        const GAME_STATE_HIDER_WAIT = "hider_wait";
        const GAME_STATE_RUNNING = "running";
        const GAME_STATE_HIDER_WINS = "hider_wins";
        const GAME_STATE_SEEKER_WINS = "seeker_wins";

        const LOCATION_UPDATE_INTERVAL_MS = 10000; // Alle 10 Sekunden Standort an Client-Backend senden
        let locationWatchId = null; // ID für navigator.geolocation.watchPosition
        let lastLocationSentTime = 0; // Zeitstempel des letzten gesendeten Standort-Updates

        const SERVER_HOST_KEY = 'hideAndSeekServerHost'; // Schlüssel für localStorage
        const SERVER_PORT_KEY = 'hideAndSeekServerPort'; // Schlüssel für localStorage

        // Hilfsfunktionen für DOM-Manipulation
        function $(selector) { return document.querySelector(selector); }
        function show(id) { const el = $(`#${id}`); if (el) el.classList.add('visible'); }
        function hide(id) { const el = $(`#${id}`); if (el) el.classList.remove('visible'); }
        function setText(id, textContent) { const el = $(`#${id}`); if (el) el.textContent = textContent || ''; }
        function setHtml(id, htmlContent) { const el = $(`#${id}`); if (el) el.innerHTML = htmlContent || ''; }
        function toggleDisplay(id, showFlag, displayType = 'block') {
            const el = $(`#${id}`);
            if (el) el.style.display = showFlag ? displayType : 'none';
        }

        // Lokales Speichern und Laden der Server-Details für bequemes Wiederverbinden
        function saveServerDetails(host, port) {
            try { localStorage.setItem(SERVER_HOST_KEY, host); localStorage.setItem(SERVER_PORT_KEY, port); }
            catch (e) { console.warn("localStorage nicht verfügbar:", e); }
        }

        function loadServerDetails() {
            try { return { host: localStorage.getItem(SERVER_HOST_KEY), port: localStorage.getItem(SERVER_PORT_KEY) }; }
            catch (e) { console.warn("localStorage nicht verfügbar:", e); return { host: null, port: null }; }
        }

        function initializeServerInputs() {
            // Lädt die zuletzt verwendeten Serverdetails in die Eingabefelder
            const loadedDetails = loadServerDetails();
            const serverHostInput = $('#server-host'); const serverPortInput = $('#server-port');
            if (serverHostInput && loadedDetails.host) serverHostInput.value = loadedDetails.host;
            if (serverPortInput && loadedDetails.port) serverPortInput.value = loadedDetails.port;
        }

        function resetDynamicUIElements() {
            // Setzt alle UI-Elemente auf ihren Standardzustand zurück (versteckt/leer)
            document.querySelectorAll('#app-container > .container.section').forEach(el => el.classList.remove('visible'));
            // Nachrichtenfelder leeren und verstecken
            ['game-message', 'error-message', 'location-error-message', 'join-error-message'].forEach(id => {
                setText(id, ''); toggleDisplay(id, false);
            });
            toggleDisplay('messages-section', false); // Nachrichten-Sektion selbst auch verstecken, wenn keine Nachrichten

            // Join-Sektion Status
            setText('join-socket-status-display', 'Prüfe...'); $('#join-socket-status-display').className = 'dimmed';
            setText('join-game-status-display', 'Verbinde...');
            const joinButton = $('#join-game-button'); if (joinButton) joinButton.disabled = true;

            // Pending Lobby Sektion Status
            setText('pending-lobby-player-name', ''); setText('pending-lobby-player-role-wish', '');
            setText('pending-lobby-socket-status-display', 'Warte auf Server...');
            setText('pending-lobby-game-status-display', 'Warte auf Server...');
            const confirmLobbyButton = $('#confirm-lobby-join-button'); if(confirmLobbyButton) confirmLobbyButton.disabled = true;

            // Player Sektion allgemeine Infos
            setText('player-socket-connection-status', 'Prüfe...'); $('#player-socket-connection-status').className = 'dimmed'; // NEU
            setText('player-name', 'N/A'); setText('player-id', 'N/A'); setText('player-role', 'N/A');
            setText('player-status-ingame', 'N/A'); setText('game-status-display', 'Lade...');
            toggleDisplay('hider-wait-countdown-container', false); setText('hider-wait-time-left', '0');
            toggleDisplay('game-time-left-container', false); setText('game-time-left', '0');
            setText('player-location', 'Warte auf GPS...'); toggleDisplay('mapLink', false, 'inline'); setText('player-accuracy', 'N/A');
            toggleDisplay('hider-warning-text', false);

            // Early End Vote Container
            toggleDisplay('early-end-vote-container', false);
            const earlyEndBtn = $('#request-early-end-button');
            if(earlyEndBtn) { earlyEndBtn.disabled = true; earlyEndBtn.textContent = 'Runde vorzeitig beenden';}
            setText('early-end-vote-info', '0/0 Spieler wollen Runde beenden.');

            // Server Management Container
            toggleDisplay('server-management-container', false);
            const forceResetBtn = $('#force-server-reset-button'); if(forceResetBtn) { forceResetBtn.disabled = true;}

            // Lobby Sektion
            setHtml('lobby-player-list', '<li class="dimmed">Warte auf Spieler...</li>');
            const readyButton = $('#ready-button');
            if (readyButton) { readyButton.textContent = 'Klicken: Ich bin bereit!'; readyButton.className = 'ready'; readyButton.disabled = true; }

            // Hider Sektion
            setText('hider-skips-available-display', '0');
            toggleDisplay('hider-task-info', false); setText('task-description', ''); setText('task-points', ''); setText('task-time-left', '0');
            const completeTaskButton = $('#complete-task-form button'); if(completeTaskButton) completeTaskButton.disabled = true;
            const skipTaskButton = $('#skip-task-button');
            if(skipTaskButton) { toggleDisplay(skipTaskButton.id, false); skipTaskButton.disabled = true; if($('#skips-left-in-button')) setText('skips-left-in-button', '0'); }
            toggleDisplay('hider-no-task-message', true); // Default, wenn keine Aufgabe da
            updateHiderStatusMessages(null); // Setzt alle Hider-Status-Nachrichten auf display: none
            const hiderTbody = $('#hider-leaderboard tbody'); if (hiderTbody) hiderTbody.innerHTML = '';
            toggleDisplay('hider-leaderboard-container', false);

            // NEU: Pre-cached tasks
            setHtml('hider-precached-tasks-list', '');
            toggleDisplay('hider-precached-tasks-container', false);


            // Seeker Sektion
            setHtml('seeker-hider-list', ''); toggleDisplay('seeker-no-hiders-message', true);
            const seekerHiderContainer = $('#seeker-hider-locations-container'); if(seekerHiderContainer) toggleDisplay(seekerHiderContainer.id, true);

            // Alle Spieler Sektion
            setHtml('all-players-list', '<li class="dimmed">Keine Spielerinformationen.</li>');

            // Game Over Sektion
            setText('game-over-message', '');
            const gameOverTbody = $('#game-over-leaderboard tbody'); if (gameOverTbody) gameOverTbody.innerHTML = '';
            toggleDisplay('game-over-leaderboard-container', false);
            const goToRegButton = $('#go-to-registration-button'); if(goToRegButton) goToRegButton.disabled = false;
        }

        function updateUI(data) {
            // Setzt die UI-Elemente zurück und aktualisiert sie dann basierend auf den neuen Daten
            resetDynamicUIElements();
            currentPlayerData = JSON.parse(JSON.stringify(data)); // Tiefenkopie der Daten

            let messagesWereShown = false;
            // Nachrichten vom Server anzeigen
            // NEU: Logik für Offline-Queue-Verarbeitung und spezifische Nachricht
            if (data.is_processing_offline_queue) {
                setText('game-message', 'Synchronisiere Offline-Aktionen mit dem Server...');
                toggleDisplay('game-message', true); messagesWereShown = true;
            } else if (data.game_message && data.game_message.includes("Alle Offline-Aktionen erfolgreich synchronisiert.")) {
                setText('game-message', data.game_message); toggleDisplay('game-message', true); messagesWereShown = true;
                setTimeout(() => { toggleDisplay('game-message', false); if(currentPlayerData) currentPlayerData.game_message = null; }, 4000); // Länger anzeigen
            } else if (data.game_message) {
                setText('game-message', data.game_message); toggleDisplay('game-message', true); messagesWereShown = true; setTimeout(() => { toggleDisplay('game-message', false); if(currentPlayerData) currentPlayerData.game_message = null; }, 5000);
            }

            if (data.error_message) { setText('error-message', data.error_message); toggleDisplay('error-message', true); messagesWereShown = true; setTimeout(() => { toggleDisplay('error-message', false); if(currentPlayerData) currentPlayerData.error_message = null; }, 8000); }
            // join_error wird nur angezeigt, wenn keine player_id vorhanden ist oder der Spieler auf Lobby-Bestätigung wartet
            if (data.join_error && (!data.player_id || (data.player_id && data.game_state?.status === GAME_STATE_LOBBY && !data.confirmed_for_lobby) )) { setText('join-error-message', data.join_error); toggleDisplay('join-error-message', true); messagesWereShown = true; }
            const locationErrorEl = $('#location-error-message');
            if (locationErrorEl && locationErrorEl.style.display !== 'none' && locationErrorEl.textContent) messagesWereShown = true; // Prüfen, ob vorheriger Standortfehler noch angezeigt wird
            if(messagesWereShown) show('messages-section'); // Nur Nachrichten-Sektion anzeigen, wenn tatsächlich Nachrichten da sind

            const serverGameStatus = data.game_state?.status;
            const serverGameStatusDisplay = data.game_state?.status_display || "Lade...";
            const isSocketConnected = data.is_socket_connected_to_server === true;

            // --- Update des globalen Socket-Verbindungsstatus ---
            // Für den Join-Screen
            setText('join-socket-status-display', isSocketConnected ? "Verbunden" : "Nicht verbunden");
            $('#join-socket-status-display').className = isSocketConnected ? 'status-connected' : 'status-disconnected'; // NEU: class for styling
            // Für den Player-Screen
            const playerSocketStatusEl = $('#player-socket-connection-status');
            if (playerSocketStatusEl) {
                if (isSocketConnected) {
                    setText(playerSocketStatusEl.id, 'Verbunden zum Spielserver');
                    playerSocketStatusEl.className = 'status-connected';
                } else {
                    setText(playerSocketStatusEl.id, 'GETRENNT - Versuche Wiederverbindung...');
                    playerSocketStatusEl.className = 'status-disconnected';
                }
            }


            // --- Standort-Anzeige ---
            const locationDisplay = $('#player-location');
            if (data.location && data.location.length >= 2) {
                locationDisplay.textContent = `Lat: ${parseFloat(data.location[0]).toFixed(5)}, Lon: ${parseFloat(data.location[1]).toFixed(5)} (Server)`;
                $('#mapLink a').href = `https://www.google.com/maps?q=${data.location[0]},${data.location[1]}`;
                toggleDisplay('mapLink', true, 'inline');
                if (data.location.length > 2 && data.location[2] !== null) setText('player-accuracy', parseFloat(data.location[2]).toFixed(1));
                else setText('player-accuracy', 'N/A');
            } else if (locationWatchId !== null) { // Wenn GPS aktiv ist, aber noch keine Server-Daten
                locationDisplay.textContent = 'Standort wird vom Browser ermittelt...'; toggleDisplay('mapLink', false); setText('player-accuracy', 'N/A');
            } else { // Wenn kein GPS aktiv oder keine Daten
                locationDisplay.textContent = 'Standort unbekannt.'; toggleDisplay('mapLink', false); setText('player-accuracy', 'N/A');
            }

            // Hider Warnungstext
            toggleDisplay('hider-warning-text', data.role === 'hider' && data.hider_location_update_imminent === true && data.player_status === 'active');

            // Early End Vote Container
            const earlyEndVoteContainer = $('#early-end-vote-container');
            const earlyEndVoteButton = $('#request-early-end-button');
            const earlyEndVoteInfo = $('#early-end-vote-info');
            // Zeige den Early-End-Vote nur an, wenn der Spieler eine ID hat, aktiv ist und das Spiel läuft oder in der Hider-Wartezeit ist.
            if ((serverGameStatus === GAME_STATE_RUNNING || serverGameStatus === GAME_STATE_HIDER_WAIT) && data.player_id && data.player_status === 'active') {
                toggleDisplay(earlyEndVoteContainer.id, true);
                earlyEndVoteButton.disabled = data.player_has_requested_early_end || !isSocketConnected; // Deaktiviere, wenn bereits abgestimmt oder Socket getrennt
                earlyEndVoteButton.textContent = data.player_has_requested_early_end ? 'Abstimmung gesendet' : 'Runde vorzeitig beenden';
                earlyEndVoteInfo.textContent = `${data.early_end_requests_count || 0} / ${data.total_active_players_for_early_end || 0} Spieler wollen Runde beenden.`;
            } else { toggleDisplay(early-end-vote-container.id, false); }

            // Server Management Container
            const serverMgmtContainer = $('#server-management-container');
            const forceResetButton = $('#force-server-reset-button');
            if (serverMgmtContainer && forceResetButton) {
                // Server Management immer anzeigen, wenn Socket verbunden, damit man resetten kann, auch wenn man nicht im Spiel ist.
                toggleDisplay(serverMgmtContainer.id, isSocketConnected);
                forceResetButton.disabled = !isSocketConnected; // Button nur aktiv, wenn Socket verbunden
            }


            // --- Haupt-Sektions-Logik basierend auf player_id und game_state ---
            if (!data.player_id) { // Kein Spieler (mehr) im Client bekannt -> Join-Screen
                show('join-section'); // Zeige den Join-Screen
                // Setze die Nickname- und Rollen-Eingabefelder vorab, falls Werte in Session oder Vorschlag da sind
                const nicknameInput = $('#nickname'); const roleChoiceInput = $('#role-choice');
                const serverHostInput = $('#server-host'); const serverPortInput = $('#server-port');
                if (document.activeElement !== nicknameInput) { // Nur aktualisieren, wenn User nicht gerade tippt
                    if (data.player_name) nicknameInput.value = data.player_name; // Vom Server (z.B. bei Join-Fehler)
                    else if (data.session_nickname) nicknameInput.value = data.session_nickname; // Aus der Flask-Session
                    else if (data.prefill_nickname && (nicknameInput.value === "" || nicknameInput.value.startsWith("Spieler"))) nicknameInput.value = data.prefill_nickname;
                }
                if (document.activeElement !== roleChoiceInput) {
                    if (data.role) roleChoiceInput.value = data.role;
                    else if (data.session_role_choice) roleChoiceInput.value = data.session_role_choice;
                }
                // Serverdetails aus den Client-Daten oder localStorage vorfüllen
                if (document.activeElement !== serverHostInput) {
                    if (data.current_server_host) serverHostInput.value = data.current_server_host;
                    else { const ld = loadServerDetails(); if (ld.host) serverHostInput.value = ld.host; }
                }
                if (document.activeElement !== serverPortInput) {
                    if (data.current_server_port) serverPortInput.value = data.current_server_port;
                    else { const ld = loadServerDetails(); if (ld.port) serverPortInput.value = ld.port; }
                }

                // Join-Button aktivieren, wenn Eingaben da sind. Das eigentliche Senden hängt vom Socket ab.
                $('#join-game-button').disabled = false;
                // Wenn player_name bekannt, aber keine player_id (z.B. nach JOIN_GAME, aber Server hat noch nicht geantwortet)
                if (data.player_name && !data.player_id && isSocketConnected && serverGameStatus !== "disconnected") {
                    setText('join-game-status-display', serverGameStatusDisplay || "Sende Beitrittsanfrage...");
                }

            } else { // Spieler hat eine gültige ID vom Server erhalten
                show('player-section'); // Zeige die Haupt-Spielerinformationen
                setText('player-name', data.player_name || "Unbekannt"); setText('player-id', data.player_id);
                setText('player-role', data.role || "Unbekannt");

                // Status des Spielers (aktiv, gefangen etc.)
                let playerStatusText = 'Unbekannt';
                if (data.player_status === 'active') playerStatusText = 'Aktiv im Spiel';
                else if (data.player_status === 'caught') playerStatusText = 'Gefangen (jetzt Seeker)';
                else if (data.player_status === 'failed_task') playerStatusText = 'Ausgeschieden (Aufgabe verfehlt)';
                else if (data.player_status === 'failed_loc_update') playerStatusText = 'Ausgeschieden (Standort nicht aktualisiert)';
                else if (data.player_status === 'offline') playerStatusText = 'Offline (wird bei Wiederverbindung aktualisiert)'; // NEU
                setText('player-status-ingame', playerStatusText);
                setText('game-status-display', serverGameStatusDisplay); // Aktueller Spielstatus vom Server

                // Logic basierend auf dem Spielzustand und Bestätigung für Lobby
                if (data.is_waiting_for_lobby) { // Spieler ist registriert, wartet aber auf nächste Lobby-Runde
                    show('pending-lobby-join-section');
                    setText('pending-lobby-player-name', data.player_name || "Dein Name");
                    setText('pending-lobby-player-role-wish', data.role || "Deine Rolle");
                    setText('pending-lobby-socket-status-display', isSocketConnected ? "Verbunden" : "Nicht verbunden");
                    $('#pending-lobby-socket-status-display').className = isSocketConnected ? 'status-connected' : 'status-disconnected';
                    setText('pending-lobby-game-status-display', serverGameStatusDisplay);
                    $('#confirm-lobby-join-button').disabled = !isSocketConnected; // Button nur aktiv, wenn Socket verbunden
                } else if (!data.confirmed_for_lobby && serverGameStatus === GAME_STATE_LOBBY) {
                    // Sollte durch is_waiting_for_lobby eigentlich nicht erreicht werden,
                    // falls Spieler bereits in "waiting_for_lobby" war und nun die Lobby startet.
                    // Für einen frischen Join in Lobby, der noch nicht "confirmed" ist.
                    show('pending-lobby-join-section');
                    setText('pending-lobby-player-name', data.player_name || "Dein Name");
                    setText('pending-lobby-player-role-wish', data.role || "Deine Rolle");
                    setText('pending-lobby-socket-status-display', isSocketConnected ? "Verbunden" : "Nicht verbunden");
                    $('#pending-lobby-socket-status-display').className = isSocketConnected ? 'status-connected' : 'status-disconnected';
                    setText('pending-lobby-game-status-display', serverGameStatusDisplay);
                    $('#confirm-lobby-join-button').disabled = !isSocketConnected;
                } else if (data.confirmed_for_lobby && serverGameStatus === GAME_STATE_LOBBY) {
                    // Spieler ist in der Lobby und hat bestätigt
                    show('lobby-section');
                    updateLobbyPlayerList(data.lobby_players, String(data.player_id));
                    const readyButton = $('#ready-button');
                    readyButton.textContent = data.player_is_ready ? 'Status: Bereit (Klick zum Ändern)' : 'Klicken: Ich bin bereit!';
                    readyButton.className = data.player_is_ready ? 'unready' : 'ready';
                    readyButton.disabled = !isSocketConnected; // Button nur aktiv, wenn Socket verbunden
                } else if (serverGameStatus === GAME_STATE_HIDER_WAIT) {
                    // Hider-Vorbereitungszeit
                    toggleDisplay('hider-wait-countdown-container', true);
                    setText('hider-wait-time-left', data.game_state?.hider_wait_time_left || '0');
                    if (data.role === 'hider') {
                        show('hider-section');
                        setText('hider-skips-available-display', data.task_skips_available || 0);
                        updateHiderTask(data.current_task, data.task_skips_available);
                        // NEU: Anzeige von Pre-cached Tasks
                        const precachedTasksContainer = $('#hider-precached-tasks-container');
                        const precachedTasksList = $('#hider-precached-tasks-list');
                        if (data.player_status === 'active' && !data.current_task && data.pre_cached_tasks && data.pre_cached_tasks.length > 0) {
                            toggleDisplay(precachedTasksContainer.id, true);
                            setHtml(precachedTasksList.id, ''); // Leeren
                            data.pre_cached_tasks.forEach(ptask => {
                                const li = document.createElement('li');
                                li.innerHTML = `<strong>${ptask.description}</strong> (${ptask.points} P.)`;
                                precachedTasksList.appendChild(li);
                            });
                            toggleDisplay('hider-no-task-message', false); // Verstecke "Warte auf Aufgabe"
                        } else {
                            toggleDisplay(precachedTasksContainer.id, false);
                        }

                    }
                    else if (data.role === 'seeker') { show('seeker-section'); }
                    show('all-players-section'); updateAllPlayersList(data.all_players_status, String(data.player_id));
                } else if (serverGameStatus === GAME_STATE_RUNNING) {
                    // Spiel läuft
                    toggleDisplay('game-time-left-container', true);
                    const timeLeft = data.game_state?.game_time_left || 0;
                    setText('game-time-left', `${Math.floor(timeLeft / 60)} Min ${timeLeft % 60} Sek`);

                    if (data.role === 'hider') {
                        show('hider-section'); setText('hider-skips-available-display', data.task_skips_available || 0);
                        updateHiderTask(data.current_task, data.task_skips_available);
                        updateHiderLeaderboard(data.hider_leaderboard, String(data.player_id), 'hider-leaderboard');
                        // NEU: Anzeige von Pre-cached Tasks
                        const precachedTasksContainer = $('#hider-precached-tasks-container');
                        const precachedTasksList = $('#hider-precached-tasks-list');
                        if (data.player_status === 'active' && !data.current_task && data.pre_cached_tasks && data.pre_cached_tasks.length > 0) {
                            toggleDisplay(precachedTasksContainer.id, true);
                            setHtml(precachedTasksList.id, ''); // Leeren
                            data.pre_cached_tasks.forEach(ptask => {
                                const li = document.createElement('li');
                                li.innerHTML = `<strong>${ptask.description}</strong> (${ptask.points} P.)`;
                                precachedTasksList.appendChild(li);
                            });
                             toggleDisplay('hider-no-task-message', false); // Verstecke "Warte auf Aufgabe"
                        } else {
                            toggleDisplay(precachedTasksContainer.id, false);
                        }

                    } else if (data.role === 'seeker') {
                        show('seeker-section'); updateSeekerHiderList(data.hider_locations, isSocketConnected);
                    }
                    show('all-players-section'); updateAllPlayersList(data.all_players_status, String(data.player_id));
                } else if (serverGameStatus === GAME_STATE_HIDER_WINS || serverGameStatus === GAME_STATE_SEEKER_WINS) {
                    // Spielende
                    show('game-over-section');
                    setText('game-over-message', data.game_state?.game_over_message || "Das Spiel ist vorbei.");
                    updateHiderLeaderboard(data.hider_leaderboard, String(data.player_id), 'game-over-leaderboard');
                    $('#go-to-registration-button').disabled = false; // Button zum Neuregistrieren aktivieren
                }
            }
            // Standort-Updates starten/stoppen basierend auf dem Spielstatus und ob der Spieler eine ID hat
            if (data.player_id && (serverGameStatus === GAME_STATE_LOBBY || serverGameStatus === GAME_STATE_HIDER_WAIT || serverGameStatus === GAME_STATE_RUNNING)) {
                startLocationUpdates();
            } else { stopLocationUpdates(); }
        }

        function updateLobbyPlayerList(lobbyPlayers, currentPlayerIdStr) {
            const ul = $('#lobby-player-list'); setHtml('lobby-player-list', '');
            if (lobbyPlayers && Object.keys(lobbyPlayers).length > 0) {
                for (const pid in lobbyPlayers) {
                    const p = lobbyPlayers[pid]; const li = document.createElement('li');
                    let roleDisplay = p.role === 'hider' ? 'Hider' : (p.role === 'seeker' ? 'Seeker' : 'Unbekannt');
                    let readyDisplay = p.is_ready ? '<span class="status-active">Bereit</span>' : '<span class="dimmed">Wartet...</span>';
                    li.innerHTML = `${p.name} (Rolle: ${roleDisplay}) - Status: ${readyDisplay}`;
                    if (pid === currentPlayerIdStr) li.classList.add('highlight');
                    ul.appendChild(li);
                }
            } else { ul.innerHTML = '<li class="dimmed">Warte auf weitere Spieler...</li>'; }
        }

        function updateAllPlayersList(allPlayers, currentPlayerIdStr) {
            const el = $('#all-players-list'); setHtml('all-players-list', '');
            if (allPlayers && Object.keys(allPlayers).length > 0) {
                for (const pid in allPlayers) {
                    const p = allPlayers[pid]; const li = document.createElement('li');
                    let statusDisplay;
                    if (p.status === 'active') statusDisplay = '<span class="status-active">Aktiv</span>';
                    else if (p.status === 'caught') statusDisplay = '<span class="status-caught">Gefangen</span>';
                    else if (p.status === 'failed_task') statusDisplay = '<span class="status-failed">Aufgabe verfehlt</span>';
                    else if (p.status === 'failed_loc_update') statusDisplay = '<span class="status-failed-loc">Kein Standort</span>';
                    else if (p.status === 'offline') statusDisplay = '<span class="status-offline">Offline</span>'; // NEU
                    else statusDisplay = `<span class="dimmed">${p.status || 'Unbekannt'}</span>`;
                    li.innerHTML = `${p.name} (Rolle: ${p.role || 'N/A'}) - ${statusDisplay}`;
                    if (pid === currentPlayerIdStr) li.classList.add('highlight');
                    el.appendChild(li);
                }
            } else { el.innerHTML = '<li class="dimmed">Keine Spielerinformationen.</li>'; }
        }

        function updateHiderTask(task, taskSkipsAvailable) {
            const socketConnected = currentPlayerData && currentPlayerData.is_socket_connected_to_server === true;
            const isActiveHider = currentPlayerData && currentPlayerData.role === 'hider' && currentPlayerData.player_status === 'active';
            const skipTaskButton = $('#skip-task-button'); const skipsLeftInButtonSpan = $('#skips-left-in-button');
            const completeTaskButton = $('#complete-task-form button'); // NEU: Referenz zum Button

            if (task && task.description && isActiveHider) {
                toggleDisplay('hider-task-info', true);
                toggleDisplay('hider-no-task-message', false); // Verstecke "Warte auf Aufgabe"
                toggleDisplay('hider-precached-tasks-container', false); // Verstecke Pre-cached Tasks

                setText('task-description', task.description); setText('task-points', task.points);
                setText('task-time-left', task.time_left_seconds);

                // NEU: Complete Task Button ist klickbar, wenn der Spieler aktiv ist und eine Aufgabe hat,
                // auch wenn er offline ist (die Aktion wird gecached)
                if (completeTaskButton) {
                    completeTaskButton.disabled = !(isActiveHider && task && task.description);
                }

                if (skipTaskButton && skipsLeftInButtonSpan) {
                    const numSkips = typeof taskSkipsAvailable === 'number' ? taskSkipsAvailable : 0;
                    toggleDisplay(skipTaskButton.id, true);
                    // Skip Task Button ist nur aktiv, wenn online ODER wenn offline (um caching zu ermöglichen)
                    // und Skips verfügbar sind und eine Aufgabe da ist.
                    skipTaskButton.disabled = !(socketConnected || !socketConnected) || numSkips <= 0 || !task.description;
                    setText(skipsLeftInButtonSpan.id, numSkips);
                    skipTaskButton.title = numSkips > 0 ? "Diese Aufgabe überspringen" : "Keine Skips mehr verfügbar";
                }
            } else {
                toggleDisplay('hider-task-info', false);
                if (completeTaskButton) completeTaskButton.disabled = true; // Button deaktivieren, wenn keine Aufgabe da

                // Zeige "Warte auf Aufgabe" nur, wenn Hider und aktiv, aber keine Aufgabe UND keine Precached Tasks sichtbar
                const precachedVisible = $('#hider-precached-tasks-container').style.display !== 'none';
                toggleDisplay('hider-no-task-message', isActiveHider && !precachedVisible);

                if (skipTaskButton) toggleDisplay(skipTaskButton.id, false); // Überspringen-Button verstecken, wenn keine Aufgabe
            }
        }

        function updateHiderStatusMessages(playerStatus) {
            toggleDisplay('hider-caught-message', playerStatus === 'caught');
            toggleDisplay('hider-failed-task-message', playerStatus === 'failed_task');
            toggleDisplay('hider-failed-location-message', playerStatus === 'failed_loc_update');
        }

        function updateHiderLeaderboard(leaderboardData, currentPlayerIdStr, tableId = 'hider-leaderboard') {
            const table = $(`#${tableId}`); const tbody = table ? table.querySelector('tbody') : null;
            const containerId = (tableId === 'hider-leaderboard') ? 'hider-leaderboard-container' : 'game-over-leaderboard-container';
            if (!tbody) { toggleDisplay(containerId, false); return; }
            tbody.innerHTML = '';
            const isHiderRole = currentPlayerData && currentPlayerData.role === 'hider';
            const isGameOver = currentPlayerData && currentPlayerData.game_state && (currentPlayerData.game_state.status === GAME_STATE_HIDER_WINS || currentPlayerData.game_state.status === GAME_STATE_SEEKER_WINS);

            if (leaderboardData && leaderboardData.length > 0 && (isHiderRole || isGameOver )) {
                toggleDisplay(containerId, true);
                leaderboardData.forEach(entry => {
                    const row = tbody.insertRow();
                    row.insertCell().textContent = entry.name; row.insertCell().textContent = entry.points;
                    const statusCell = row.insertCell(); let statusDisplay;
                    if (entry.status === 'active') statusDisplay = '<span class="status-active">Aktiv</span>';
                    else if (entry.status === 'caught') statusDisplay = '<span class="status-caught">Gefangen</span>';
                    else if (entry.status === 'failed_task') statusDisplay = '<span class="status-failed">Aufgabe verfehlt</span>';
                    else if (entry.status === 'failed_loc_update') statusDisplay = '<span class="status-failed-loc">Kein Standort</span>';
                    else if (entry.status === 'offline') statusDisplay = '<span class="status-offline">Offline</span>'; // NEU
                    else statusDisplay = `<span class="dimmed">${entry.status || 'Unbekannt'}</span>`;
                    statusCell.innerHTML = statusDisplay;
                    if (String(entry.id) === currentPlayerIdStr) row.classList.add('highlight');
                });
            } else { toggleDisplay(containerId, false); }
        }

        function updateSeekerHiderList(hiderLocations, isSocketConnected) { // isSocketConnected als Parameter hinzugefügt
            const ul = $('#seeker-hider-list'); const noHidersMsg = $('#seeker-no-hiders-message');
            ul.innerHTML = '';
            const isActiveSeeker = currentPlayerData && currentPlayerData.role === 'seeker' && currentPlayerData.player_status === 'active';

            if (isActiveSeeker && hiderLocations && Object.keys(hiderLocations).length > 0) {
                toggleDisplay(noHidersMsg.id, false);
                for (const hiderId in hiderLocations) {
                    const hider = hiderLocations[hiderId]; const li = document.createElement('li');
                    li.innerHTML = `<strong>${hider.name}</strong> (Gesehen: ${hider.timestamp || 'N/A'})
                        <br><span class="dimmed">Lat: ${parseFloat(hider.lat).toFixed(4)}, Lon: ${parseFloat(hider.lon).toFixed(4)}</span>
                        <a href="https://www.google.com/maps?q=${hider.lat},${hider.lon}" target="_blank" style="margin-left: 5px;">Karte</a>
                        <button class="catch-hider-btn action-btn" data-hider-id="${hiderId}" ${!isSocketConnected ? 'disabled' : ''}>Fangen!</button>`; // Button-Status hängt von Socket-Verbindung ab
                    ul.appendChild(li);
                }
                document.querySelectorAll('.catch-hider-btn').forEach(button => {
                    button.onclick = async function() { this.disabled = true; await sendClientAction('/catch_hider', { hider_id_to_catch: this.dataset.hiderId }, this); };
                });
            } else { toggleDisplay(noHidersMsg.id, isActiveSeeker); }
        }

        async function sendClientAction(endpoint, bodyPayload = null, triggeringButton = null) {
            // Deaktiviere den Button sofort, um Mehrfachklicks zu verhindern
            if (triggeringButton) triggeringButton.disabled = true;
            else if (endpoint === '/join_game') { const joinBtn = $('#join-game-button'); if (joinBtn) joinBtn.disabled = true; }

            try {
                const options = { method: 'POST', headers: {'Content-Type': 'application/json'}};
                if (bodyPayload) options.body = JSON.stringify(bodyPayload);
                const response = await fetch(endpoint, options);
                const responseData = await response.json();
                updateUI(responseData); // UI mit der Antwort des Client-Backends aktualisieren
            } catch (error) {
                console.error(`Netzwerkfehler beim Senden an Client-Backend (${endpoint}):`, error);
                // Bei Netzwerkfehler zum lokalen Client-Backend (Flask-App)
                // Fehlerstatus in currentPlayerData aktualisieren und UI neu rendern.
                const errorData = JSON.parse(JSON.stringify(currentPlayerData || {})); // Kopie der aktuellen Daten
                errorData.error_message = `Netzwerkfehler: Aktion '${endpoint.substring(1)}' fehlgeschlagen. Der lokale Client-Server antwortet nicht.`;
                if (!errorData.game_state) errorData.game_state = {};
                errorData.game_state.status_display = "Lokaler Client nicht erreichbar";
                errorData.is_socket_connected_to_server = false; // Setze den Socket-Status auf getrennt
                updateUI(errorData); // UI mit Fehlern anzeigen

                // Wenn der Button vorher deaktiviert wurde, reaktiviere ihn (es sei denn, es ist der Join-Button, der vom Backend verwaltet wird)
                // Sonderfall: complete_task_form wird vom client.py selbst behandelt, um Offline-Fähigkeit zu ermöglichen.
                // Der Button sollte NICHT reaktiviert werden, da der Client ihn eventuell gecached hat.
                if (triggeringButton && endpoint !== '/join_game' && endpoint !== '/complete_task') {
                    triggeringButton.disabled = false; // Reaktivieren, damit Nutzer erneut versuchen kann
                }
            }
        }

        // --- Geolocation API Funktionen ---
        function handleLocationSuccess(position) {
            const lat = position.coords.latitude; const lon = position.coords.longitude; const accuracy = position.coords.accuracy;
            const locationTextEl = $('#player-location');
            // Nur aktualisieren, wenn der Server noch keine Position gesendet hat oder es ein Browser-Update ist
            if (locationTextEl && !locationTextEl.textContent.includes('(Server)')) setText('player-location', `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)} (Browser)`);
            setText('player-accuracy', accuracy.toFixed(1));
            $('#mapLink a').href = `https://www.google.com/maps?q=${lat},${lon}`;
            toggleDisplay('mapLink', true, 'inline');
            const locErrorMsg = $('#location-error-message');
            if (locErrorMsg && locErrorMsg.style.display !== 'none') {
                toggleDisplay('location-error-message', false); // Standortfehler ausblenden
                // Prüfen, ob die gesamte Nachrichten-Sektion jetzt versteckt werden kann
                if (!($('#game-message').textContent || $('#error-message').textContent || $('#join-error-message').textContent)) toggleDisplay('messages-section', false);
            }
            const now = Date.now();
            // Standortdaten an das Client-Backend senden, aber nur, wenn eine player_id vorhanden ist
            // und das Intervall seit dem letzten Senden abgelaufen ist.
            if (currentPlayerData && currentPlayerData.player_id && (now - lastLocationSentTime > (LOCATION_UPDATE_INTERVAL_MS / 2) || lastLocationSentTime === 0 )) {
                sendLocationToClientBackend(lat, lon, accuracy); lastLocationSentTime = now;
            }
        }

        function handleLocationError(error) {
            let message = "Unbekannter Standortfehler";
            switch(error.code) {
                case error.PERMISSION_DENIED: message = "Zugriff auf Standort blockiert. Bitte in den Browser-Einstellungen erlauben."; break;
                case error.POSITION_UNAVAILABLE: message = "Standortinformationen nicht verfügbar. Versuche es später erneut."; break;
                case error.TIMEOUT: message = "Timeout bei der Standortabfrage. Signal schwach?"; break;
            }
            const locationTextEl = $('#player-location');
            if (locationTextEl && !locationTextEl.textContent.includes('(Server)')) setText('player-location', 'Standortfehler vom Browser.');
            setText('player-accuracy', 'N/A'); toggleDisplay('mapLink', false);
            setText('location-error-message', message); toggleDisplay('location-error-message', true);
            show('messages-section'); // Nachrichten-Sektion anzeigen, da ein Fehler aufgetreten ist
        }

        async function sendLocationToClientBackend(lat, lon, accuracy) {
            try {
                // Diese Anfrage ist FIRE-AND-FORGET, wir erwarten hier keine direkte UI-Änderung,
                // da die tatsächliche Bestätigung über den Socket vom Server kommt.
                const response = await fetch('/update_location_from_browser', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ lat: lat, lon: lon, accuracy: accuracy })
                });
                if (!response.ok) {
                    console.error("Fehler beim Senden des Standorts an Client-Backend:", response.status);
                }
            } catch (error) {
                console.error("Netzwerkfehler beim Senden des Standorts an Client-Backend:", error);
            }
        }

        function startLocationUpdates() {
            if (navigator.geolocation) {
                if (locationWatchId === null) { // Starte watchPosition nur einmal
                    locationWatchId = navigator.geolocation.watchPosition(handleLocationSuccess, handleLocationError,
                        { enableHighAccuracy: true, timeout: LOCATION_UPDATE_INTERVAL_MS * 2, maximumAge: 0 }); // MaximumAge 0 erzwingt immer neue Position
                    console.log("Geolocation watchPosition gestartet.");
                }
            } else {
                const locTextEl = $('#player-location');
                if(locTextEl && !locTextEl.textContent.includes('(Server)')) setText('player-location', 'Browser-Geolocation nicht unterstützt.');
                setText('location-error-message', 'Dein Browser unterstützt keine Geolocation API.');
                toggleDisplay('location-error-message', true); show('messages-section');
            }
        }

        function stopLocationUpdates() {
            if (navigator.geolocation && locationWatchId !== null) {
                navigator.geolocation.clearWatch(locationWatchId);
                locationWatchId = null;
                console.log("Geolocation watchPosition gestoppt.");
            }
        }

        // --- Event Listener für Buttons und Formulare ---

        // Formular für Spiel beitreten
        $('#join-form').addEventListener('submit', async (event) => {
            event.preventDefault(); // Standardformular-Submit verhindern
            const nickname = $('#nickname').value; const role = $('#role-choice').value;
            const serverHost = $('#server-host').value; const serverPort = $('#server-port').value;

            if (!serverHost || !serverPort || !nickname) {
                let joinError = $('#join-error-message');
                setText(joinError.id, 'Nickname, Server-Host und Port sind erforderlich.');
                toggleDisplay(joinError.id, true); show('messages-section');
                event.submitter.disabled = false; // Button wieder aktivieren, da Client-seitiger Fehler
                return;
            }
            saveServerDetails(serverHost, serverPort); // Serverdetails lokal speichern
            await sendClientAction('/join_game', { nickname, role, server_host: serverHost, server_port: serverPort }, event.submitter);
        });

        // Button: Lobby beitreten (nach erfolgreicher Registrierung)
        $('#confirm-lobby-join-button')?.addEventListener('click', async (event) => {
            await sendClientAction('/confirm_lobby_join', null, event.target);
        });

        // Formular: Bereit-Status umschalten
        $('#ready-form').addEventListener('submit', async (event) => {
            event.preventDefault();
            // Schaltet den Bereit-Status um (true -> false, false -> true)
            const newReadyStatus = !(currentPlayerData.player_is_ready || false);
            await sendClientAction('/set_ready', { ready_status: newReadyStatus }, event.submitter);
        });

        // Button: Aufgabe als erledigt markieren
        $('#complete-task-form button')?.addEventListener('click', async (event) => {
            event.preventDefault();
            await sendClientAction('/complete_task', null, event.target);
        });

        // Button: Runde vorzeitig beenden
        $('#request-early-end-button')?.addEventListener('click', async (event) => {
            await sendClientAction('/request_early_round_end_action', null, event.target);
        });

        // Button: Aufgabe überspringen
        $('#skip-task-button')?.addEventListener('click', async (event) => {
            event.preventDefault();
            await sendClientAction('/skip_task', null, event.target);
        });

        // Button: Server zurücksetzen (Admin-Funktion)
        $('#force-server-reset-button')?.addEventListener('click', async (event) => {
            if (confirm("Bist du sicher, dass du den Spielserver für ALLE Spieler zurücksetzen möchtest? Dies kann nicht rückgängig gemacht werden!")) {
                await sendClientAction('/force_server_reset_from_ui', null, event.target);
            } else {
                // Wenn Abbruch, Button wieder aktivieren (könnte durch sendClientAction deaktiviert worden sein)
                event.target.disabled = !(currentPlayerData && currentPlayerData.is_socket_connected_to_server === true);
            }
        });

        // Funktion: Zum Registrierungsbildschirm zurückkehren (vom Game Over Screen)
        async function handleGoToRegistration() {
            const goToRegButton = $('#go-to-registration-button');
            // Sende Aktion an Client-Backend, die den lokalen Zustand auf "nicht beigetreten" setzt
            // und den Server ggf. über das Verlassen informiert.
            await sendClientAction('/leave_game_and_go_to_join_screen', null, goToRegButton);
        }

        // --- Polling Funktion ---
        async function fetchStatusAndUpdateUI() {
            try {
                const response = await fetch('/status'); // Fragt den lokalen Client-Backend nach dem aktuellen Status
                if (!response.ok) {
                    console.error("Fehler Client-Backend-Verbindung:", response.status, response.statusText);
                    const tempErrorData = JSON.parse(JSON.stringify(currentPlayerData || {}));
                    if (!tempErrorData.game_state) tempErrorData.game_state = {};
                    tempErrorData.game_state.status_display = `Fehler Client-Server (${response.status}).`;
                    tempErrorData.error_message = "Verbindung zum lokalen Client-Server (Python) verloren.";
                    tempErrorData.is_socket_connected_to_server = false; // Auch den Spielserver-Socket als getrennt markieren
                    updateUI(tempErrorData); // UI mit Fehlern aktualisieren
                    return;
                }
                const data = await response.json();
                updateUI(data); // UI mit den empfangenen Daten aktualisieren
            } catch (error) {
                console.error("Netzwerkfehler zum lokalen Client-Backend:", error);
                const tempErrorData = JSON.parse(JSON.stringify(currentPlayerData || {}));
                if (!tempErrorData.game_state) tempErrorData.game_state = {};
                tempErrorData.game_state.status_display = "Client-Server (Python) nicht erreichbar.";
                tempErrorData.error_message = "Lokaler Client-Server (Python) antwortet nicht.";
                tempErrorData.is_socket_connected_to_server = false;
                updateUI(tempErrorData);
            }
        }

        // --- Initialisierung beim Laden der Seite ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeServerInputs(); // Serverdetails aus localStorage laden
            fetchStatusAndUpdateUI(); // Erster Statusabruf
            setInterval(fetchStatusAndUpdateUI, 2500); // Regelmäßiges Polling alle 2.5 Sekunden
        });
    </script>
</body>
</html>
