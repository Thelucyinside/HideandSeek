import socket
import json
import time
import threading
import random
import traceback

# Configuration
SERVER_HOST = "127.0.0.1"
SERVER_PORT = 65432
SPAM_DELAY = 0.01
DEFAULT_RECEIVE_TIMEOUT = 1
SERVER_RESET_WAIT_TIME = 3
LARGE_DATA_LENGTH = 10000 # Default length for large data tests

# --- Core Utility Functions ---
def connect_to_server(host, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        sock.settimeout(None)
        return sock
    except socket.timeout: print(f"Connection to {host}:{port} timed out."); return None
    except ConnectionRefusedError: print(f"Connection to {host}:{port} refused."); return None
    except Exception as e: print(f"Error connecting to server: {e}"); return None

def send_json_message(sock, message_dict):
    try:
        message_json = json.dumps(message_dict) + '\n'
        sock.sendall(message_json.encode('utf-8'))
        return True
    except BrokenPipeError: print("Error sending JSON: Broken pipe."); return False
    except ConnectionResetError: print("Error sending JSON: Connection reset."); return False
    except Exception as e: print(f"Error sending JSON: {e}"); return False

def send_raw_data(sock, raw_string):
    try:
        message_bytes = (raw_string + '\n').encode('utf-8')
        sock.sendall(message_bytes)
        return True
    except BrokenPipeError: print("Error sending raw: Broken pipe."); return False
    except ConnectionResetError: print("Error sending raw: Connection reset."); return False
    except Exception as e: print(f"Error sending raw: {e}"); return False

def receive_message(sock, timeout=DEFAULT_RECEIVE_TIMEOUT):
    try:
        sock.settimeout(timeout)
        data_bytes = sock.recv(4096)
        if not data_bytes: return None
        raw_data = data_bytes.decode('utf-8', errors='ignore').strip()
        try:
            return json.loads(raw_data)
        except json.JSONDecodeError:
            return {"error": "json_decode_error", "raw_data": raw_data, "note": "Response might be larger than 4096 bytes"}
    except socket.timeout: return None
    except ConnectionResetError: return None
    except Exception as e: print(f"Receive message error: {e}"); return None

def get_player_id_from_response(response):
    if isinstance(response, dict):
        if response.get("type") == "game_update" and "player_id" in response: return response["player_id"]
        if response.get("action") == "JOIN_GAME_ACK" and "player_id" in response: return response["player_id"]
        if response.get("type") == "error" and "details" in response and "player_id" in response["details"]: return response["details"]["player_id"]
    return None

def full_join_sequence(sock, player_name, role):
    join_msg = {"action": "JOIN_GAME", "name": player_name, "role_preference": role}
    if not send_json_message(sock, join_msg): print(f"   full_join_sequence: Failed to send JOIN_GAME for {player_name}."); return None
    response = receive_message(sock, timeout=2); player_id = get_player_id_from_response(response)
    if not player_id: time.sleep(0.2); response = receive_message(sock, timeout=1); player_id = get_player_id_from_response(response)
    if not player_id: print(f"   full_join_sequence: Could not get player_id for {player_name}. Resp: {response}"); return None

    confirm_msg = {"action": "CONFIRM_LOBBY_JOIN"}
    if not send_json_message(sock, confirm_msg): print(f"   full_join_sequence: Failed to send CONFIRM_LOBBY_JOIN for {player_name}."); return player_id

    ready_msg = {"action": "SET_READY", "ready_status": True}
    if not send_json_message(sock, ready_msg): print(f"   full_join_sequence: Failed to send SET_READY for {player_name}."); return player_id

    time.sleep(0.1)
    while receive_message(sock, timeout=0.1):
        pass
    return player_id

def initial_join_and_ready(sock, player_name, role, get_id=True): # Used by spam tests
    join_msg = {"action": "JOIN_GAME", "name": player_name, "role_preference": role}
    if not send_json_message(sock, join_msg): print(f"{player_name}: Failed to send JOIN_GAME."); return None
    response = receive_message(sock); player_id = get_player_id_from_response(response)
    if not player_id and get_id:
        time.sleep(0.1); response = receive_message(sock); player_id = get_player_id_from_response(response)
    if not player_id and get_id: print(f"{player_name}: Could not get player_id. Resp: {response}"); return None

    confirm_msg = {"action": "CONFIRM_LOBBY_JOIN"}
    if not send_json_message(sock, confirm_msg): print(f"{player_name}: Failed to send CONFIRM_LOBBY_JOIN."); return player_id

    ready_msg = {"action": "SET_READY", "ready_status": True}
    if not send_json_message(sock, ready_msg): print(f"{player_name}: Failed to send SET_READY."); return player_id
    time.sleep(0.1)
    while receive_message(sock, timeout=0.1): # Drain queue
        pass
    return player_id

# --- Rejoin Test Functions ---
def test_normal_rejoin(host, port):
    print("\n--- Running Test: Normal Rejoin ---")
    sock = None; player_id = None; player_name = "Rejoiner"
    try:
        sock = connect_to_server(host, port)
        if not sock: print("Normal Rejoin: Initial connection failed."); return
        join_msg = {"action": "JOIN_GAME", "name": player_name, "role_preference": "hider"}
        if not send_json_message(sock, join_msg): print("Normal Rejoin: Failed to send JOIN_GAME."); return
        response = receive_message(sock, timeout=2); print(f"Normal Rejoin (Initial Join) Response: {response}")
        player_id = get_player_id_from_response(response)
        if not player_id :
            if response and response.get("action") == "JOIN_GAME_ACK" and "player_id" in response: player_id = response["player_id"]
            elif response and response.get("type") == "error" and response.get("details", {}).get("player_id"): player_id = response["details"]["player_id"]
            else: print("Normal Rejoin: Failed to get player_id."); return
        print(f"Normal Rejoin: Player ID: {player_id}")
    finally:
        if sock: sock.close()
    if not player_id: print("Normal Rejoin: Cannot proceed, player_id not obtained."); return
    print(f"Normal Rejoin: Waiting {SERVER_RESET_WAIT_TIME/3}s before rejoin attempt..."); time.sleep(SERVER_RESET_WAIT_TIME/3)
    sock_rejoin = None
    try:
        sock_rejoin = connect_to_server(host, port)
        if not sock_rejoin: print("Normal Rejoin: Reconnection failed."); return
        rejoin_msg = {"action": "REJOIN_GAME", "player_id": player_id, "name": player_name}
        if not send_json_message(sock_rejoin, rejoin_msg): print("Normal Rejoin: Failed to send REJOIN_GAME."); return
        rejoin_response = receive_message(sock_rejoin, timeout=2); print(f"Normal Rejoin (Rejoin Attempt) Response: {rejoin_response}")
    finally:
        if sock_rejoin: sock_rejoin.close()
    # print("--- Test: Normal Rejoin Finished ---") # Will be printed by main loop

def test_rejoin_invalid_id(host, port):
    print("\n--- Running Test: Rejoin with Invalid ID ---")
    sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print("Invalid ID Rejoin: Connection failed."); return
        rejoin_msg = {"action": "REJOIN_GAME", "player_id": "INVALID_ID_12345", "name": "FakeRejoiner"}
        if not send_json_message(sock, rejoin_msg): print("Invalid ID Rejoin: Failed to send REJOIN_GAME."); return
        response = receive_message(sock); print(f"Invalid ID Rejoin Response: {response}")
    finally:
        if sock: sock.close()
    # print("--- Test: Rejoin with Invalid ID Finished ---")

def test_rejoin_impersonate_attempt(host, port):
    print("\n--- Running Test: Rejoin Impersonation Attempt ---")
    sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print("Impersonation Rejoin: Connection failed."); return
        rejoin_msg = {"action": "REJOIN_GAME", "player_id": "impersonation_attempt_id_999", "name": "Impersonator"}
        if not send_json_message(sock, rejoin_msg): print("Impersonation Rejoin: Failed to send REJOIN_GAME."); return
        response = receive_message(sock); print(f"Impersonation Rejoin Response: {response}")
    finally:
        if sock: sock.close()
    # print("--- Test: Rejoin Impersonation Attempt Finished ---")

def test_rapid_rejoin_cycles(host, port, cycles=3):
    print(f"\n--- Running Test: Rapid Rejoin Cycles ({cycles} cycles) ---")
    player_name_base = "RapidRejoiner"
    for i in range(cycles):
        print(f"\nRapid Rejoin Cycle {i+1}/{cycles}"); sock_join, player_id = None, None; current_name = f"{player_name_base}_{i+1}"
        try:
            sock_join = connect_to_server(host, port)
            if not sock_join: print(f"Cycle {i+1}: Initial connection failed."); time.sleep(0.5); continue
            join_msg = {"action": "JOIN_GAME", "name": current_name, "role_preference": "seeker"}
            if not send_json_message(sock_join, join_msg): print(f"Cycle {i+1}: Failed to send JOIN_GAME."); time.sleep(0.5); continue
            response = receive_message(sock_join, timeout=2); print(f"Cycle {i+1} (Initial Join) Response: {response}")
            player_id = get_player_id_from_response(response)
            if not player_id:
                if response and response.get("action") == "JOIN_GAME_ACK" and "player_id" in response: player_id = response["player_id"]
                elif response and response.get("type") == "error" and response.get("details", {}).get("player_id"): player_id = response["details"]["player_id"]
                else: print(f"Cycle {i+1}: Failed to get player_id."); time.sleep(0.5); continue
            print(f"Cycle {i+1}: Player ID: {player_id}")
        finally:
            if sock_join: sock_join.close()
        if not player_id: time.sleep(0.5); continue
        time.sleep(0.5)
        sock_rejoin = None
        try:
            sock_rejoin = connect_to_server(host, port)
            if not sock_rejoin: print(f"Cycle {i+1}: Reconnection failed."); time.sleep(0.5); continue
            rejoin_msg = {"action": "REJOIN_GAME", "player_id": player_id, "name": current_name}
            if not send_json_message(sock_rejoin, rejoin_msg): print(f"Cycle {i+1}: Failed to send REJOIN_GAME."); continue
            rejoin_response = receive_message(sock_rejoin, timeout=2); print(f"Cycle {i+1} (Rejoin Attempt) Response: {rejoin_response}")
        finally:
            if sock_rejoin: sock_rejoin.close()
        time.sleep(0.5)
    # print("--- Test: Rapid Rejoin Cycles Finished ---")

# --- Spam Test Functions ---
def spam_update_location(host, port, num_spam=10):
    print(f"\n--- Running Test: Spam UPDATE_LOCATION ({num_spam} times) ---"); sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print(f"LocationSpammer: Connection failed."); return
        player_id = initial_join_and_ready(sock, "LocationSpammer", "hider", get_id=True)
        if not player_id: print(f"LocationSpammer: Initial join or getting player_id failed."); return
        print(f"LocationSpammer: Joined. Starting UPDATE_LOCATION spam..."); successful_sends = 0
        for i in range(num_spam):
            update_msg = {"action": "UPDATE_LOCATION", "latitude": random.uniform(-90,90), "longitude": random.uniform(-180,180)}
            if not send_json_message(sock, update_msg): print(f"LocationSpammer: Send fail iter {i+1}. Stop."); break
            successful_sends +=1; time.sleep(SPAM_DELAY)
        print(f"LocationSpammer: UPDATE_LOCATION spamming complete ({successful_sends}/{num_spam} sent).")
    finally:
        if sock: sock.close()
    # print("--- Test: Spam UPDATE_LOCATION Finished ---")

def spam_set_ready_toggle(host, port, num_toggles=5):
    print(f"\n--- Running Test: Spam SET_READY Toggle ({num_toggles*2} messages) ---"); sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print(f"ReadySpammer: Connection failed."); return
        if not initial_join_and_ready(sock, "ReadySpammer", "seeker", get_id=False): print(f"ReadySpammer: Initial join/ready failed."); return
        print(f"ReadySpammer: Joined. Starting SET_READY toggle spam..."); successful_toggles = 0
        for i in range(num_toggles):
            if not send_json_message(sock, {"action": "SET_READY", "ready_status": True}): print(f"ReadySpammer: Send True fail iter {i+1}. Stop."); break
            time.sleep(SPAM_DELAY)
            if not send_json_message(sock, {"action": "SET_READY", "ready_status": False}): print(f"ReadySpammer: Send False fail iter {i+1}. Stop."); break
            successful_toggles+=1; time.sleep(SPAM_DELAY)
        print(f"ReadySpammer: SET_READY toggle spam complete ({successful_toggles}/{num_toggles} toggles sent).")
    finally:
        if sock: sock.close()
    # print("--- Test: Spam SET_READY Toggle Finished ---")

def spam_task_complete(host, port, num_spam=10):
    print(f"\n--- Running Test: Spam TASK_COMPLETE ({num_spam} times) ---"); sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print(f"TaskSpammer: Connection failed."); return
        player_id = initial_join_and_ready(sock, "TaskSpammer", "hider", get_id=True)
        if not player_id: print(f"TaskSpammer: Initial join/ready failed."); return
        print(f"TaskSpammer: Joined. Starting TASK_COMPLETE spam..."); successful_sends = 0
        for i in range(num_spam):
            task_msg = {"action": "TASK_COMPLETE", "task_id": f"dummy_task_{random.randint(1,10)}"}
            if not send_json_message(sock, task_msg): print(f"TaskSpammer: Send fail iter {i+1}. Stop."); break
            successful_sends+=1; time.sleep(SPAM_DELAY)
        print(f"TaskSpammer: TASK_COMPLETE spam complete ({successful_sends}/{num_spam} sent).")
    finally:
        if sock: sock.close()
    # print("--- Test: Spam TASK_COMPLETE Finished ---")

def spam_request_early_end(host, port, num_spam=10):
    print(f"\n--- Running Test: Spam REQUEST_EARLY_ROUND_END ({num_spam} times) ---"); sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print(f"EarlyEndSpammer: Connection failed."); return
        player_id = initial_join_and_ready(sock, "EarlyEndSpammer", "seeker", get_id=True)
        if not player_id: print(f"EarlyEndSpammer: Initial join/ready failed."); return
        print(f"EarlyEndSpammer: Joined. Starting REQUEST_EARLY_ROUND_END spam..."); successful_sends = 0
        for i in range(num_spam):
            if not send_json_message(sock, {"action": "REQUEST_EARLY_ROUND_END"}): print(f"EarlyEndSpammer: Send fail iter {i+1}. Stop."); break
            successful_sends+=1; time.sleep(SPAM_DELAY)
        print(f"EarlyEndSpammer: REQUEST_EARLY_ROUND_END spam complete ({successful_sends}/{num_spam} sent).")
    finally:
        if sock: sock.close()
    # print("--- Test: Spam REQUEST_EARLY_ROUND_END Finished ---")

# --- Malformed Data Test Functions ---
def test_incomplete_json(host, port):
    print("\n--- Running Test: Incomplete JSON Data ---")
    payloads = ['{"action":"JOIN_GAME","name":"Incomplete"', '{"action":"UPDATE_LOCATION","latitude":10.5', '{', '}']
    for i, payload in enumerate(payloads):
        sock = None; print(f" Sub-test {i+1}: Sending: {payload}")
        try:
            sock = connect_to_server(host, port)
            if not sock: print(f"  Connection failed sub-test {i+1}."); continue
            send_raw_data(sock, payload)
            response = receive_message(sock); print(f"  Response {i+1}: {response if response else 'No resp/Timeout'}")
        finally:
            if sock: sock.close()
        time.sleep(0.5)
    # print("--- Test: Incomplete JSON Data Finished ---")

def test_incorrect_data_types(host, port):
    print("\n--- Running Test: Incorrect Data Types ---"); sock = None
    messages = [
        {"action": "SET_READY", "ready_status": "not_a_boolean"},
        {"action": "UPDATE_LOCATION", "latitude": "not_a_float", "longitude": 10.0},
        {"action": "JOIN_GAME", "name": 12345, "role_preference": "hider"},
    ]
    try:
        sock = connect_to_server(host, port)
        if not sock: print(" Initial connection failed."); return
        initial_join_and_ready(sock, "DataTypeTester", "seeker", get_id=False)
        time.sleep(0.1)
        while receive_message(sock,0.1):
            pass
        for i, msg in enumerate(messages):
            print(f" Sub-test {i+1}: Sending: {msg}")
            if not send_json_message(sock, msg):
                print(f"  Send fail {i+1}. Reconnecting...")
                if sock: sock.close()
                sock=connect_to_server(host,port)
                if not sock: break
                initial_join_and_ready(sock,f"DT{i+1}","seeker",False)
                if not send_json_message(sock,msg): continue
            response = receive_message(sock); print(f"  Response {i+1}: {response if response else 'No resp/Timeout'}")
            if response is None and sock:
                 try:
                     sock.getpeername() # Check if connected
                     print("  Server may have closed. Reconnecting...")
                 except socket.error: # Already closed or error
                     pass
                 if sock: sock.close()
                 sock=connect_to_server(host,port)
                 if not sock: break
                 initial_join_and_ready(sock,f"DTRe{i+1}","seeker",False)
    finally:
        if sock: sock.close()
    # print("--- Test: Incorrect Data Types Finished ---")

def test_missing_parameters(host, port):
    print("\n--- Running Test: Missing Parameters ---"); sock = None
    messages = [{"action": "JOIN_GAME", "name": "MissingRole"}, {"action": "SET_READY"}]
    try:
        sock = connect_to_server(host, port)
        if not sock: print(" Initial connection failed."); return
        initial_join_and_ready(sock, "MissingParamTester", "hider", get_id=False)
        time.sleep(0.1)
        while receive_message(sock,0.1):
            pass
        for i, msg in enumerate(messages):
            print(f" Sub-test {i+1}: Sending: {msg}")
            if not send_json_message(sock, msg):
                print(f"  Send fail {i+1}. Reconnecting...")
                if sock: sock.close()
                sock=connect_to_server(host,port)
                if not sock: break
                initial_join_and_ready(sock,f"MP{i+1}","hider",False)
                if not send_json_message(sock,msg): continue
            response = receive_message(sock); print(f"  Response {i+1}: {response if response else 'No resp/Timeout'}")
            if response is None and sock:
                try:
                    sock.getpeername() # Check if connected
                    print("  Server may have closed. Reconnecting...")
                except socket.error: # Already closed or error
                    pass
                if sock: sock.close()
                sock=connect_to_server(host,port)
                if not sock: break
                initial_join_and_ready(sock,f"MPRe{i+1}","hider",False)
    finally:
        if sock: sock.close()
    # print("--- Test: Missing Parameters Finished ---")

def test_extra_parameters(host, port):
    print("\n--- Running Test: Extra Parameters ---"); sock = None
    message = {"action": "JOIN_GAME", "name": "ExtraParam", "role_preference": "seeker", "unexpected_field": "surprise!"}
    try:
        sock = connect_to_server(host, port)
        if not sock: print(" Connection failed."); return
        print(f" Sending: {message}")
        send_json_message(sock, message)
        response = receive_message(sock, timeout=2); print(f" Response: {response if response else 'No resp/Timeout'}")
    finally:
        if sock: sock.close()
    # print("--- Test: Extra Parameters Finished ---")

def test_non_json_data(host, port):
    print("\n--- Running Test: Non-JSON Data ---")
    payloads = ["Hello Server", "GET / HTTP/1.1", "<msg>text</msg>", "\x00\x01\x02"]
    for i, payload in enumerate(payloads):
        sock = None; print(f" Sub-test {i+1}: Sending: {payload[:50]}{'...'if len(payload)>50 else ''}")
        try:
            sock = connect_to_server(host, port)
            if not sock: print(f"  Connection failed sub-test {i+1}."); continue
            send_raw_data(sock, payload)
            response = receive_message(sock); print(f"  Response {i+1}: {response if response else 'No resp/Timeout'}")
        finally:
            if sock: sock.close()
        time.sleep(0.5)
    # print("--- Test: Non-JSON Data Finished ---")

# --- Invalid Action Sequence Test Functions ---
def test_task_complete_invalid_state(host, port):
    print("\n--- Running Test: TASK_COMPLETE in Invalid State ---")
    print(" Scenario 1: TASK_COMPLETE as Seeker"); sock1 = None
    try:
        sock1 = connect_to_server(host, port)
        if sock1:
            if full_join_sequence(sock1, "SeekerTasker", "seeker"):
                print("  Sending TASK_COMPLETE..."); send_json_message(sock1, {"action": "TASK_COMPLETE", "task_id": "dummy_task_seeker"})
                response = receive_message(sock1); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Join sequence failed S1.")
        else: print("  Connection failed S1.")
    finally:
        if sock1: sock1.close()
    time.sleep(0.5); print("\n Scenario 2: TASK_COMPLETE as Hider in Lobby"); sock2 = None
    try:
        sock2 = connect_to_server(host, port)
        if sock2:
            print("  Joining as HiderLobbyTasker (hider)...")
            if send_json_message(sock2, {"action": "JOIN_GAME", "name": "HiderLobbyTasker", "role_preference": "hider"}):
                receive_message(sock2) # Absorb potential ack
                print("  Sending TASK_COMPLETE (before confirm/ready)..."); send_json_message(sock2, {"action": "TASK_COMPLETE", "task_id": "dummy_task_lobby"})
                response = receive_message(sock2); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Failed to send JOIN_GAME S2.")
        else: print("  Connection failed S2.")
    finally:
        if sock2: sock2.close()
    # print("--- Test: TASK_COMPLETE in Invalid State Finished ---")

def test_catch_hider_invalid_state(host, port):
    print("\n--- Running Test: CATCH_HIDER in Invalid State ---")
    print(" Scenario 1: CATCH_HIDER as Hider"); sock1 = None
    try:
        sock1 = connect_to_server(host, port)
        if sock1:
            if full_join_sequence(sock1, "HiderCatcher", "hider"):
                print("  Sending CATCH_HIDER..."); send_json_message(sock1, {"action": "CATCH_HIDER", "hider_id_to_catch": "dummy_hider_id"})
                response = receive_message(sock1); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Join sequence failed S1.")
        else: print("  Connection failed S1.")
    finally:
        if sock1: sock1.close()
    time.sleep(0.5); print("\n Scenario 2: CATCH_HIDER as Seeker in Lobby"); sock2 = None
    try:
        sock2 = connect_to_server(host, port)
        if sock2:
            print("  Joining as SeekerLobbyCatcher (seeker)...")
            if send_json_message(sock2, {"action": "JOIN_GAME", "name": "SeekerLobbyCatcher", "role_preference": "seeker"}):
                receive_message(sock2) # Absorb potential ack
                print("  Sending CATCH_HIDER (before confirm/ready)..."); send_json_message(sock2, {"action": "CATCH_HIDER", "hider_id_to_catch": "dummy_hider_id_lobby"})
                response = receive_message(sock2); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Failed to send JOIN_GAME S2.")
        else: print("  Connection failed S2.")
    finally:
        if sock2: sock2.close()
    # print("--- Test: CATCH_HIDER in Invalid State Finished ---")

def test_set_ready_invalid_state(host, port):
    print("\n--- Running Test: SET_READY in Invalid State ---")
    print(" Scenario 1: SET_READY before CONFIRM_LOBBY_JOIN"); sock1 = None
    try:
        sock1 = connect_to_server(host, port)
        if sock1:
            print("  Joining as EarlyReady...")
            if send_json_message(sock1, {"action": "JOIN_GAME", "name": "EarlyReady", "role_preference": "hider"}):
                receive_message(sock1) # Absorb potential ack
                print("  Sending SET_READY: True (before CONFIRM)..."); send_json_message(sock1, {"action": "SET_READY", "ready_status": True})
                response = receive_message(sock1); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Failed to send JOIN_GAME S1.")
        else: print("  Connection failed S1.")
    finally:
        if sock1: sock1.close()
    time.sleep(0.5); print("\n Scenario 2: SET_READY again after initial ready"); sock2 = None
    try:
        sock2 = connect_to_server(host, port)
        if sock2:
            if full_join_sequence(sock2, "DoubleReady", "seeker"):
                print("  Sending SET_READY: True again..."); send_json_message(sock2, {"action": "SET_READY", "ready_status": True})
                response = receive_message(sock2); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Join sequence failed S2.")
        else: print("  Connection failed S2.")
    finally:
        if sock2: sock2.close()
    # print("--- Test: SET_READY in Invalid State Finished ---")

def test_actions_before_join_or_confirm(host, port):
    print("\n--- Running Test: Actions Before JOIN or CONFIRM ---")
    print(" Scenario 1: UPDATE_LOCATION before JOIN_GAME"); sock1 = None
    try:
        sock1 = connect_to_server(host, port)
        if sock1:
            print("  Sending UPDATE_LOCATION..."); send_json_message(sock1, {"action": "UPDATE_LOCATION", "latitude": 10, "longitude": 10})
            response = receive_message(sock1); print(f"  Response: {response if response else 'No resp/Timeout or disconnect'}")
        else: print("  Connection failed S1.")
    finally:
        if sock1: sock1.close()
    time.sleep(0.5); print("\n Scenario 2: UPDATE_LOCATION after JOIN_GAME, before CONFIRM"); sock2 = None
    try:
        sock2 = connect_to_server(host, port)
        if sock2:
            print("  Joining as UnconfirmedPlayer...")
            if send_json_message(sock2, {"action": "JOIN_GAME", "name": "UnconfirmedPlayer", "role_preference": "hider"}):
                receive_message(sock2) # Absorb potential ack
                print("  Sending UPDATE_LOCATION (before CONFIRM)..."); send_json_message(sock2, {"action": "UPDATE_LOCATION", "latitude": 20, "longitude": 20})
                response = receive_message(sock2); print(f"  Response: {response if response else 'No resp/Timeout'}")
            else: print("  Failed to send JOIN_GAME S2.")
        else: print("  Connection failed S2.")
    finally:
        if sock2: sock2.close()
    # print("--- Test: Actions Before JOIN or CONFIRM Finished ---")

# --- Critical Action Test Functions ---
def test_force_server_reset(host, port, player_name="ResetTrigger"):
    print("\n--- Running Test: FORCE_SERVER_RESET_FROM_CLIENT ---")
    print(f" Part 1: Sending FORCE_SERVER_RESET as {player_name}..."); sock_trigger = None
    try:
        sock_trigger = connect_to_server(host, port)
        if sock_trigger:
            reset_command = {"action": "FORCE_SERVER_RESET_FROM_CLIENT"}
            print(f"   Sending command: {reset_command}"); send_json_message(sock_trigger, reset_command)
            response = receive_message(sock_trigger, timeout=1)
            print(f"   Response from server after sending reset: {response if response else 'No immediate response/Timeout'}")
            print("   FORCE_SERVER_RESET_FROM_CLIENT command sent.")
        else: print("   Part 1: Connection failed.")
    except Exception as e: print(f"   Error during Part 1: {e}")
    finally:
        if sock_trigger: sock_trigger.close(); print("   Trigger socket closed.")
    print(f"\n Waiting {SERVER_RESET_WAIT_TIME}s for server to reset..."); time.sleep(SERVER_RESET_WAIT_TIME)
    print("\n Part 2: Attempting to connect and join post-reset..."); sock_verify = None
    try:
        sock_verify = connect_to_server(host, port)
        if sock_verify:
            print("   Successfully reconnected."); post_reset_player_name = "PostResetPlayer"
            join_msg = {"action": "JOIN_GAME", "name": post_reset_player_name, "role_preference": "hider"}
            print(f"   Attempting JOIN_GAME as {post_reset_player_name}...")
            if send_json_message(sock_verify, join_msg):
                response = receive_message(sock_verify, timeout=2)
                print(f"   Response from JOIN_GAME post-reset: {response if response else 'No response/Timeout'}")
                if response and (get_player_id_from_response(response) or response.get("action") == "JOIN_GAME_ACK"):
                    print("   SUCCESS: Joined game after reset.")
                else: print("   FAILURE: Could not join or no valid response after reset.")
            else: print("   FAILURE: Failed to send JOIN_GAME post-reset.")
        else: print("   FAILURE: Could not reconnect after reset.")
    except Exception as e: print(f"   Error during Part 2: {e}")
    finally:
        if sock_verify: sock_verify.close(); print("   Verification socket closed.")
    # print("--- Test: FORCE_SERVER_RESET_FROM_CLIENT Finished ---")

# --- Large Data Test Functions ---
def test_large_nickname_join(host, port, nickname_length=2000): # Reduced default for faster full run
    print(f"\n--- Running Test: JOIN_GAME with Large Nickname (length: {nickname_length}) ---"); sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock: print("  Connection failed."); return
        long_nickname = 'A' * nickname_length
        print(f"  Attempting join with nickname (first 100 chars): '{long_nickname[:100]}{'...' if nickname_length > 100 else ''}'")
        join_message = {"action": "JOIN_GAME", "name": long_nickname, "role_preference": "hider"}
        if send_json_message(sock, join_message):
            print("  JOIN_GAME with large nickname sent.")
            response = receive_message(sock, timeout=5)
            if response:
                print(f"  Server Response (first 500 chars): {str(response)[:500]}{'...' if len(str(response)) > 500 else ''}")
                player_id = get_player_id_from_response(response)
                if player_id: print(f"  SUCCESS/WARN: Server accepted. Player ID: {player_id}. Verify truncation.")
                elif response.get("type") == "error": print(f"  INFO: Server rejected with error: {response.get('message', 'N/A')}")
                else: print(f"  WARN: Response not clear success/error: {response}")
            else: print("  INFO/WARN: No response or server disconnected.")
        else: print("  Failed to send JOIN_GAME with large nickname.")
    except Exception as e: print(f"  Error during large nickname test: {e}")
    finally:
        if sock: sock.close(); print("  Socket closed.")
    # print("--- Test: JOIN_GAME with Large Nickname Finished ---")


if __name__ == "__main__":
    print("Pentest client script - Comprehensive Tests Run")

    # Default reduced parameters for full suite run
    # These can be overridden by command-line arguments or direct modification if needed for specific detailed tests.
    DEFAULT_CYCLES = 1
    DEFAULT_SPAM_COUNT = 10
    DEFAULT_TOGGLE_COUNT = 5
    DEFAULT_LARGE_NICKNAME_LENGTH = 2000

    rejoin_tests = [
        test_normal_rejoin,
        test_rejoin_invalid_id,
        test_rejoin_impersonate_attempt,
        lambda: test_rapid_rejoin_cycles(SERVER_HOST, SERVER_PORT, cycles=DEFAULT_CYCLES)
    ]
    spam_tests = [
        lambda: spam_update_location(SERVER_HOST, SERVER_PORT, num_spam=DEFAULT_SPAM_COUNT),
        lambda: spam_set_ready_toggle(SERVER_HOST, SERVER_PORT, num_toggles=DEFAULT_TOGGLE_COUNT),
        lambda: spam_task_complete(SERVER_HOST, SERVER_PORT, num_spam=DEFAULT_SPAM_COUNT),
        lambda: spam_request_early_end(SERVER_HOST, SERVER_PORT, num_spam=DEFAULT_SPAM_COUNT)
    ]
    malformed_data_tests = [
        test_incomplete_json,
        test_incorrect_data_types,
        test_missing_parameters,
        test_extra_parameters,
        test_non_json_data
    ]
    invalid_sequence_tests = [
        test_task_complete_invalid_state,
        test_catch_hider_invalid_state,
        test_set_ready_invalid_state,
        test_actions_before_join_or_confirm
    ]
    critical_action_tests = [
        test_force_server_reset # This one uses its internal player_name
    ]
    large_data_tests = [
        lambda: test_large_nickname_join(SERVER_HOST, SERVER_PORT, nickname_length=DEFAULT_LARGE_NICKNAME_LENGTH)
    ]

    all_tests = (
        rejoin_tests +
        spam_tests +
        malformed_data_tests +
        invalid_sequence_tests +
        critical_action_tests +
        large_data_tests
    )

    print(f"--- Running ALL {len(all_tests)} Pentest Scenarios ---")
    # Reduced counts for spam/cycle tests are now handled by lambdas with default-like values for the full run.

    for i, test_func_or_lambda in enumerate(all_tests):
        test_name = ""
        try:
            # Attempt to get a meaningful name for the test
            if hasattr(test_func_or_lambda, '__name__'): # Direct function
                test_name = test_func_or_lambda.__name__
            elif hasattr(test_func_or_lambda, '__closure__') and test_func_or_lambda.__closure__: # Lambda
                closure_vars = test_func_or_lambda.__code__.co_freevars
                func_name_in_lambda = ""
                # Try to find the original function name in lambda's scope if it's simple
                for var_name in closure_vars:
                    cell_contents = test_func_or_lambda.__closure__[closure_vars.index(var_name)].cell_contents
                    if callable(cell_contents) and hasattr(cell_contents, '__name__'):
                        func_name_in_lambda = cell_contents.__name__
                        break
                if func_name_in_lambda:
                     test_name = f"lambda_for_{func_name_in_lambda}"
                else: # Fallback for more complex lambdas or if name isn't found
                    test_name = f"lambda_test_scenario_{i+1}"
            else: # Fallback if no name can be inferred
                test_name = f"test_scenario_{i+1}"

            # print(f"\n--- Starting Test ({i+1}/{len(all_tests)}): {test_name} ---") # Test name is printed by test func now

            if callable(test_func_or_lambda):
                # FIXED: Corrected the __name__ check for lambdas. It should be '<lambda>' not '<lambda__'.
                if hasattr(test_func_or_lambda, '__name__') and test_func_or_lambda.__name__ == '<lambda>':
                    test_func_or_lambda()  # Call lambda with no arguments
                else:
                    # Assume it's a direct function reference expecting host and port
                    test_func_or_lambda(SERVER_HOST, SERVER_PORT)
            else:
                print(f"ERROR: Test case {test_name} is not callable.")

            # print(f"--- Finished Test: {test_name} ---") # Test function should print its own end banner
        except Exception as e:
            print(f"CRITICAL ERROR during {test_name}: {e}")
            print(traceback.format_exc())
        finally:
            print("-" * 40) # Separator printed by main loop
            time.sleep(1) # Delay between different test functions/lambdas

    print("\n--- All Pentest Scenarios Complete ---")
