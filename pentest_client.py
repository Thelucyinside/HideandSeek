import socket
import json
import time
import threading
import random

# Configuration
SERVER_HOST = "127.0.0.1"
SERVER_PORT = 12345
SPAM_DELAY = 0.01
DEFAULT_RECEIVE_TIMEOUT = 1
SERVER_RESET_WAIT_TIME = 3
LARGE_DATA_LENGTH = 10000 # Default length for large data tests

def connect_to_server(host, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        sock.settimeout(None)
        return sock
    except socket.timeout: print(f"Connection to {host}:{port} timed out."); return None
    except ConnectionRefusedError: print(f"Connection to {host}:{port} refused."); return None
    except Exception as e: print(f"Error connecting to server: {e}"); return None

def send_json_message(sock, message_dict):
    try:
        message_json = json.dumps(message_dict) + '\n'
        sock.sendall(message_json.encode('utf-8'))
        return True
    except BrokenPipeError: print("Error sending JSON: Broken pipe."); return False
    except ConnectionResetError: print("Error sending JSON: Connection reset."); return False
    except Exception as e: print(f"Error sending JSON: {e}"); return False

def send_raw_data(sock, raw_string):
    try:
        message_bytes = (raw_string + '\n').encode('utf-8')
        sock.sendall(message_bytes)
        return True
    except BrokenPipeError: print("Error sending raw: Broken pipe."); return False
    except ConnectionResetError: print("Error sending raw: Connection reset."); return False
    except Exception as e: print(f"Error sending raw: {e}"); return False

def receive_message(sock, timeout=DEFAULT_RECEIVE_TIMEOUT):
    try:
        sock.settimeout(timeout)
        data_bytes = sock.recv(4096) # Standard buffer size
        if not data_bytes: return None

        # For very large responses, we might need to loop recv, but server usually sends small JSONs
        # This will at least capture the first part of a potentially large error or truncated success message
        raw_data = data_bytes.decode('utf-8', errors='ignore').strip() # Use errors='ignore' for robustness

        try:
            return json.loads(raw_data)
        except json.JSONDecodeError:
            # print(f"JSON decode error. Raw data (first 4096 bytes): '{raw_data}'")
            return {"error": "json_decode_error", "raw_data": raw_data, "note": "Response might be larger than 4096 bytes"}
    except socket.timeout: return None
    except ConnectionResetError: return None
    except Exception as e: print(f"Receive message error: {e}"); return None

def get_player_id_from_response(response):
    if isinstance(response, dict):
        if response.get("type") == "game_update" and "player_id" in response: return response["player_id"]
        if response.get("action") == "JOIN_GAME_ACK" and "player_id" in response: return response["player_id"]
        if response.get("type") == "error" and "details" in response and "player_id" in response["details"]: return response["details"]["player_id"]
    return None

def full_join_sequence(sock, player_name, role):
    join_msg = {"action": "JOIN_GAME", "name": player_name, "role_preference": role}
    if not send_json_message(sock, join_msg): print("   Failed to send JOIN_GAME."); return None
    response = receive_message(sock, timeout=2); player_id = get_player_id_from_response(response)
    if not player_id: time.sleep(0.2); response = receive_message(sock, timeout=1); player_id = get_player_id_from_response(response)
    if not player_id: print(f"   Could not get player_id for {player_name}. Resp: {response}"); return None
    confirm_msg = {"action": "CONFIRM_LOBBY_JOIN"}
    if not send_json_message(sock, confirm_msg): print("   Failed to send CONFIRM_LOBBY_JOIN."); return player_id
    ready_msg = {"action": "SET_READY", "ready_status": True}
    if not send_json_message(sock, ready_msg): print("   Failed to send SET_READY."); return player_id
    time.sleep(0.1); while receive_message(sock, timeout=0.1): pass
    return player_id

# --- Large Data Test Functions ---

def test_large_nickname_join(host, port, nickname_length=LARGE_DATA_LENGTH):
    print(f"\n--- Running Test: JOIN_GAME with Large Nickname (length: {nickname_length}) ---")
    sock = None
    try:
        sock = connect_to_server(host, port)
        if not sock:
            print("  Connection failed, cannot perform large nickname test.")
            return

        long_nickname = 'A' * nickname_length
        # Truncate for printing if too long, but send the full one
        print(f"  Attempting to join with nickname: '{long_nickname[:100]}{'...' if nickname_length > 100 else ''}'")

        join_message = {"action": "JOIN_GAME", "name": long_nickname, "role_preference": "hider"}

        if send_json_message(sock, join_message):
            print("  JOIN_GAME message with large nickname sent.")
            # Server might:
            # 1. Accept (possibly truncating the name, check player_id and any game_update)
            # 2. Reject with an error message (e.g., name too long)
            # 3. Crash or disconnect if not handled well (receive_message would return None)
            # 4. Send a very large error message if it echoes the name back (less likely for JSON part)

            # Increase timeout slightly as server might take longer to process/reject large data
            response = receive_message(sock, timeout=5)

            if response:
                print(f"  Server Response: {str(response)[:500]}{'...' if len(str(response)) > 500 else ''}") # Print potentially truncated response
                player_id = get_player_id_from_response(response)
                if player_id:
                    print(f"  SUCCESS/WARN: Server accepted large nickname. Player ID: {player_id}. Verify if name was truncated or stored fully.")
                elif response.get("type") == "error":
                    print(f"  INFO: Server correctly rejected large nickname with error: {response.get('message', 'No message')}")
                else:
                    print(f"  WARN: Received a response, but not a clear success or error: {response}")

            else:
                # This could mean server disconnected, or simply didn't respond within timeout
                # Check socket state if possible (though not easily done reliably here)
                print("  INFO/WARN: No response received from server within timeout, or server disconnected. This might indicate an issue or successful rejection by closing connection.")

        else:
            print("  Failed to send JOIN_GAME message with large nickname (e.g., broken pipe before full send).")

    except Exception as e:
        print(f"  An error occurred during the large nickname test: {e}")
    finally:
        if sock:
            sock.close()
            print("  Socket closed.")

    print("--- Test: JOIN_GAME with Large Nickname Finished ---")


# --- Condensed Test Functions (from previous steps, for brevity) ---
def test_normal_rejoin(h,p):pass
def test_rejoin_invalid_id(h,p):pass
def test_rejoin_impersonate_attempt(h,p):pass
def test_rapid_rejoin_cycles(h,p,c=1):pass
def spam_update_location(h,p,n=10):pass
def spam_set_ready_toggle(h,p,n=10):pass
def spam_task_complete(h,p,n=10):pass
def spam_request_early_end(h,p,n=10):pass
def test_incomplete_json(h,p):pass
def test_incorrect_data_types(h,p):pass
def test_missing_parameters(h,p):pass
def test_extra_parameters(h,p):pass
def test_non_json_data(h,p):pass
def test_task_complete_invalid_state(h,p):pass
def test_catch_hider_invalid_state(h,p):pass
def test_set_ready_invalid_state(h,p):pass
def test_actions_before_join_or_confirm(h,p):pass
def test_force_server_reset(h,p):pass


if __name__ == "__main__":
    print("Pentest client script - Comprehensive Tests")

    rejoin_tests = []
    spam_tests = []
    malformed_data_tests = []
    invalid_sequence_tests = []
    critical_action_tests = []

    large_data_tests = [
        test_large_nickname_join,
    ]

    # For focused testing:
    all_tests = large_data_tests
    # Example with custom length for large nickname test:
    # all_tests = [lambda h, p: test_large_nickname_join(h, p, nickname_length=20000)]

    # To run all tests:
    # all_tests = rejoin_tests + spam_tests + malformed_data_tests + invalid_sequence_tests + critical_action_tests + large_data_tests

    for test_func in all_tests:
        try:
            test_func(SERVER_HOST, SERVER_PORT)
        except Exception as e:
            print(f"!!! UNHANDLED EXCEPTION in {test_func.__name__}: {e} !!!")
        finally:
            print(f"--- Finished executing {test_func.__name__} ---")
            time.sleep(1)

    print("\nAll pentest scenarios concluded.")
